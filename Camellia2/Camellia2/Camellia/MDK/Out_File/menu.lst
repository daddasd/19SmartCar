C251 COMPILER V5.60.0,  menu                                                               24/03/24  10:06:24  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\Out_File\menu.obj
COMPILER INVOKED BY: E:\Keil5C251\C251\BIN\C251.EXE ..\USER\Hardware\menu.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BRO
                    -WSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\U
                    -SER\inc;..\USER\src;..\USER\Hardware;..\USER\Hardware) DEBUG PRINT(.\Out_File\menu.lst) TABS(2) OBJECT(.\Out_File\menu.o
                    -bj) 

stmt  level    source

    1          #include <menu.h>
    2          #include "zf_gpio.h"
    3          #include "SEEKFREE_OLED.h"
    4          #include "zf_delay.h"
    5          #include "myconfig.h"
    6          
    7          #define MENU_SIZE 4
    8          #define INTERVAL_TIME 500
    9          //位置环外环
   10          
   11          
   12          
   13          //--
   14          //  @brief      起始菜单显示一些初始值
   15          //  @param      void    
   16          //  @return     1 按KEY2跳转一级菜单      
   17          //--
   18          int Show_AllVal(int flag1)
   19          {
   20   1          int flag = flag1;
   21   1          while (flag == 0)
   22   1          {
   23   2              SaoMiao_Track();  // 扫描赛道
   24   2              NORMALIZATION_TRACKING_ADC(1.2, 1.5);
   25   2              show_val();  // 显示测得数据 
   26   2              
   27   2              if (key2 == 0) // 按下跳转到一级菜单
   28   2              {
   29   3                  delay_ms(10);
   30   3                  while (key2 == 0);
   31   3                  delay_ms(10);
   32   3                  oled_fill(0x00); // 清屏
   33   3                  flag = 1;
   34   3                  return 1;
   35   3              }
   36   2          }
   37   1          return 1;
   38   1      }
   39          
   40          //--
   41          //  @brief      一级菜单
   42          //  @param      void    
   43          //  @return     1 按KEY2跳转一级菜单      
   44          //--
   45          int First_menu(void)
   46          {
   47   1        int flag = 1;
   48   1        oled_p6x8str(25,0,"Set_Element"); //调整元素
   49   1        oled_p6x8str(25,1,"Set_Motor_PI"); //设置电机pi
   50   1        oled_p6x8str(25,2,"Set_Wh_Nh_PD"); //设置内外环pd
   51   1        oled_p6x8str(25,3,"Set_Speed"); //设置速度
   52   1        oled_p6x8str(25,4,"Show_Val"); //显示基础值
   53   1        oled_p6x8str(25,5,"Car_Star"); //小车启动
   54   1        while(1)
   55   1        {
   56   2          if(key3==0) // 下一项
C251 COMPILER V5.60.0,  menu                                                               24/03/24  10:06:24  PAGE 2   

   57   2          {
   58   3            delay_ms(10);
   59   3            while(key3==0);
   60   3            delay_ms(10);
   61   3            flag++;
   62   3            if(flag == 7) flag = 1;
   63   3          }
   64   2          if(key1==0) // 上一项
   65   2          {
   66   3            delay_ms(10);
   67   3            while(key1==0);
   68   3            delay_ms(10);
   69   3            flag--;
   70   3            if(flag == 0) flag = 6;
   71   3          }
   72   2          if(key2 == 0) //确定
   73   2          {
   74   3            delay_ms(10);
   75   3            while(key2 ==0);
   76   3            delay_ms(10);
   77   3            oled_fill(0x00); //清屏
   78   3            return flag; // 返回选择的选项
   79   3          }
   80   2          if(key4 == 0) //返回上级
   81   2          {
   82   3            delay_ms(10);
   83   3            while(key4 ==0);
   84   3            delay_ms(10);
   85   3            oled_fill(0x00); //清屏
   86   3            return 0; 
   87   3          }
   88   2          switch(flag) //光标移动
   89   2          {
   90   3            case 1:
   91   3            {
   92   4              oled_p6x8str(0,0,"-->"); 
   93   4              oled_p6x8str(0,1,"   "); 
   94   4              oled_p6x8str(0,2,"   ");
   95   4              oled_p6x8str(0,3,"   ");
   96   4              oled_p6x8str(0,4,"   ");
   97   4              oled_p6x8str(0,5,"   ");
   98   4            }break;
   99   3            case 2:
  100   3            {
  101   4              oled_p6x8str(0,0,"   "); 
  102   4              oled_p6x8str(0,1,"-->"); 
  103   4              oled_p6x8str(0,2,"   ");
  104   4              oled_p6x8str(0,3,"   ");
  105   4              oled_p6x8str(0,4,"   ");
  106   4              oled_p6x8str(0,5,"   ");
  107   4            }break;
  108   3            case 3:
  109   3            {
  110   4              oled_p6x8str(0,0,"   "); 
  111   4              oled_p6x8str(0,1,"   "); 
  112   4              oled_p6x8str(0,2,"-->");
  113   4              oled_p6x8str(0,3,"   ");
  114   4              oled_p6x8str(0,4,"   ");
  115   4              oled_p6x8str(0,5,"   ");
  116   4            }break;
  117   3            case 4:
  118   3            {
  119   4              oled_p6x8str(0,0,"   "); 
  120   4              oled_p6x8str(0,1,"   "); 
  121   4              oled_p6x8str(0,2,"   ");
  122   4              oled_p6x8str(0,3,"-->");
C251 COMPILER V5.60.0,  menu                                                               24/03/24  10:06:24  PAGE 3   

  123   4              oled_p6x8str(0,4,"   ");
  124   4              oled_p6x8str(0,5,"   ");
  125   4            }break;
  126   3            case 5:
  127   3            {
  128   4              oled_p6x8str(0,0,"   "); 
  129   4              oled_p6x8str(0,1,"   "); 
  130   4              oled_p6x8str(0,2,"   ");
  131   4              oled_p6x8str(0,3,"   ");
  132   4              oled_p6x8str(0,4,"-->");
  133   4              oled_p6x8str(0,5,"   ");
  134   4            }break;
  135   3            case 6:
  136   3            {
  137   4              oled_p6x8str(0,0,"   "); 
  138   4              oled_p6x8str(0,1,"   "); 
  139   4              oled_p6x8str(0,2,"   ");
  140   4              oled_p6x8str(0,3,"   ");
  141   4              oled_p6x8str(0,4,"   ");
  142   4              oled_p6x8str(0,5,"-->");
  143   4            }break;
  144   3          }
  145   2        }
  146   1      }
  147          
  148          //--
  149          //  @brief      二级元素顺序菜单
  150          //  @param      void    
  151          //  @return     0 退出二级菜单    
  152          //--
  153          
  154          
  155          
  156          int Second_Element_menu(void)
  157          {
  158   1          int flag = 1,i = 0,Order = 0,k =0;
  159   1          int menu_order[MENU_SIZE] = {0}; // 用于存储菜单项的顺序
  160   1          
  161   1          oled_p8x16str(25, 0, "L_YuanH");  // 左圆环
  162   1          oled_p8x16str(25, 2, "R_YuanH");  // 右圆环
  163   1          oled_p8x16str(25, 4, "PoDao");    // 坡道
  164   1          oled_p8x16str(25, 6, "LuZhang");      // 路障
  165   1          
  166   1          while (1)
  167   1          {
  168   2              if (key3 == 0) // 下一项
  169   2              {
  170   3                  delay_ms(10);
  171   3                  while (key3 == 0);
  172   3                  delay_ms(10);
  173   3                  flag++;
  174   3                  if (flag == MENU_SIZE + 1) flag = 1;
  175   3              }
  176   2              if (key1 == 0) // 上一项
  177   2              {
  178   3                  delay_ms(10);
  179   3                  while (key1 == 0);
  180   3                  delay_ms(10);
  181   3                  flag--;
  182   3                  if (flag == 0) flag = MENU_SIZE;
  183   3              }
  184   2              if (key2 == 0) // 确定
  185   2              {
  186   3                  delay_ms(10);
  187   3                  while (key2 == 0);
  188   3                  delay_ms(10);
C251 COMPILER V5.60.0,  menu                                                               24/03/24  10:06:24  PAGE 4   

  189   3                  Order++;
  190   3                  if(Order == 5){
  191   4                    for(k=0;k<4;k++)
  192   4                    {
  193   5                      Element_Order[k]=menu_order[k];
  194   5                    }
  195   4                    oled_fill(0x00); //清屏
  196   4                    return 0;  //返回上一级
  197   4                  }
  198   3                  menu_order[flag-1] = Order;
  199   3              } 
  200   2              if(key4 == 0) //返回上级
  201   2              {
  202   3                delay_ms(10);
  203   3                while(key4 ==0);
  204   3                delay_ms(10);
  205   3                oled_fill(0x00); //清屏
  206   3                return 0; // 返回选择的选项
  207   3              }
  208   2              // 更新光标位置和显示顺序
  209   2              for (i = 0; i < MENU_SIZE; i++)
  210   2              {
  211   3                  if (i + 1 == flag)
  212   3                      oled_p8x16str(0, i*2, "-->");  // 光标指示当前选中项
*** WARNING C188 IN LINE 212 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  213   3                  else
  214   3                      oled_p8x16str(0, i*2, "   ");
*** WARNING C188 IN LINE 214 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  215   3                      
  216   3                  // 在菜单项后显示顺序
  217   3                  oled_uint16_px8(80, i*2, menu_order[i]);
*** WARNING C188 IN LINE 217 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  218   3              } 
  219   2        }
  220   1      }
  221          
  222          //--
  223          //  @brief      二级调节电机PI菜单
  224          //  @param      void    
  225          //  @return     0 退出二级菜单    
  226          //--
  227          
  228          
  229          int Second_Motor_menu(void)
  230          {
  231   1          int flag = 0, Val_add_lose = 1, i = 0, count = 0;
  232   1          int16 long_press_delay = 0;
  233   1          int pree_delay = 0;
  234   1          float x = 0.005;
  235   1          
  236   1          oled_p8x16str(20, 0, "M_P"); 
  237   1          oled_printf_float_px8(50, 0, Motor_P, 2, 4); // 电机P
  238   1          oled_p8x16str(20, 2, "M_I"); 
  239   1          oled_printf_float_px8(50, 2, Motor_I, 2, 4); // 电机I
  240   1          oled_p8x16str(20, 4, "Add");   // 加值
  241   1          oled_p8x16str(20, 6, "Val");   // 加几倍或者减几倍
  242   1          
  243   1          while (1)
  244   1          {
  245   2              if (key3 == 0) // 下一项
  246   2              {
  247   3                  delay_ms(10);
  248   3                  while (key3 == 0);
  249   3                  delay_ms(10);
  250   3                  flag++;
  251   3                  if (flag == 5) flag = 1;
C251 COMPILER V5.60.0,  menu                                                               24/03/24  10:06:24  PAGE 5   

  252   3              }
  253   2              if (key1 == 0) // 上一项
  254   2              {
  255   3                  delay_ms(10);
  256   3                  while (key1 == 0);
  257   3                  delay_ms(10);
  258   3                  flag--;
  259   3                  if (flag == 0) flag = 4;
  260   3              } 
  261   2              if (key2 == 0) // 确定
  262   2              {
  263   3                  delay_ms(10);
  264   3                  long_press_delay = 0;
  265   3                  
  266   3                  while (key2 == 0)
  267   3                  {
  268   4                      delay_ms(10);
  269   4                      long_press_delay += 10;
  270   4                      
  271   4                      if (long_press_delay >= INTERVAL_TIME - pree_delay)
  272   4                      {
  273   5                          if (flag == 1)
  274   5                          {
  275   6                              oled_printf_float_px8(50, 0, Motor_P, 2, 4);
  276   6                              Motor_P = Motor_P + x * Val_add_lose;
  277   6                          }
  278   5                          if (flag == 2)
  279   5                          {
  280   6                              Motor_I = Motor_I + x * Val_add_lose;
  281   6                              oled_printf_float_px8(50, 2, Motor_I, 2, 4);
  282   6                          }
  283   5                          pree_delay += 150;
  284   5                          if (pree_delay > 1000) pree_delay = 1000;
  285   5                          long_press_delay = 0;
  286   5                      }
  287   4                  }
  288   3                  delay_ms(10);
  289   3                  if (long_press_delay < 800)
  290   3                  {
  291   4                      pree_delay = 0;
  292   4                      if (flag == 1)
  293   4                      {
  294   5                          oled_printf_float_px8(50, 0, Motor_P, 2, 4);
  295   5                          Motor_P = Motor_P + x * Val_add_lose;
  296   5                      }
  297   4                      if (flag == 2)
  298   4                      {
  299   5                          Motor_I = Motor_I + x * Val_add_lose;
  300   5                          oled_printf_float_px8(50, 2, Motor_I, 2, 4);
  301   5                      }
  302   4                      if (flag == 3)
  303   4                      {
  304   5                          if (count == 0)
  305   5                          {
  306   6                              oled_p8x16str(20, 4, "    ");   // 减值
  307   6                              oled_p8x16str(20, 4, "Lose");   // 减值
  308   6                              Val_add_lose = -1;
  309   6                              count = 1;
  310   6                          }
  311   5                          else if (count == 1)
  312   5                          {
  313   6                              oled_p8x16str(20, 4, "    ");   // 加值
  314   6                              oled_p8x16str(20, 4, "Add");    // 加值
  315   6                              Val_add_lose = 1;
  316   6                              count = 0;
  317   6                          }
C251 COMPILER V5.60.0,  menu                                                               24/03/24  10:06:24  PAGE 6   

  318   5                      }
  319   4                      if (flag == 4)
  320   4                      {
  321   5                          x = x + 0.001 * Val_add_lose;
  322   5                          oled_printf_float_px8(50, 6, x, 1, 4);
  323   5                      }
  324   4                  }
  325   3              } 
  326   2              if (key4 == 0)  // 返回
  327   2              {
  328   3                  delay_ms(10);
  329   3                  while (key4 == 0);
  330   3                  delay_ms(10);
  331   3                  oled_fill(0x00); // 清屏
  332   3                  return 0; // 返回选择的选项
  333   3              }
  334   2              for (i = 0; i < 4; i++)
  335   2              {
  336   3                  if (i + 1 == flag)
  337   3                      oled_p8x16str(0, i*2, "->");  // 光标指示当前选中项
*** WARNING C188 IN LINE 337 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  338   3                  else
  339   3                      oled_p8x16str(0, i*2, "  ");
*** WARNING C188 IN LINE 339 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  340   3              } 
  341   2          }
  342   1      }
  343          //--
  344          //  @brief      二级调节内外环PD菜单
  345          //  @param      void    
  346          //  @return     0 退出二级菜单    
  347          //--
  348          // 定义菜单大小
  349          
  350          // 定义菜单大小
  351          #define MENU_SIZE 4
  352          
  353          
  354          
  355          int Second__NWHuan_menu(void)
  356          {
  357   1          int flag = 1, i = 0;
  358   1          int page = 1; // 用于跟踪当前所在页面
  359   1          int page1 = 1;
  360   1          if(page == 1)
  361   1          {
  362   2             oled_fill(0x00);
  363   2          }
  364   1          while (1)
  365   1          {
  366   2              if (page == 1) {
  367   3                if(page1==1)
  368   3                {
  369   4                  oled_fill(0x00);
  370   4                  page1=2;
  371   4                }
  372   3                oled_p8x16str(22, 0, "N_P");  
  373   3                oled_printf_float_px8(45, 0, Nh_P, 2, 3); // 内环P
  374   3                oled_p8x16str(22, 2, "N_D");  
  375   3                oled_printf_float_px8(45, 2, Nh_D, 2, 3); // 内环D
  376   3                oled_p8x16str(22, 4, "W_P");  
  377   3                oled_printf_float_px8(45, 4, Wh_P, 3, 2); // 外环P
  378   3                oled_p8x16str(22, 6, "W_D");  
  379   3                oled_printf_float_px8(45, 6, Wh_D, 3, 2); // 外环D
  380   3              } else if (page == 2) {
  381   3                  if(page1==2)
C251 COMPILER V5.60.0,  menu                                                               24/03/24  10:06:24  PAGE 7   

  382   3                  {
  383   4                    oled_fill(0x00);
  384   4                    page1=1;              
  385   4                  }
  386   3                  oled_p8x16str(22, 0, "Add");
  387   3                  oled_p8x16str(22, 2, "W_Val");
  388   3                  oled_p8x16str(22, 4, "N_Val");
  389   3              }
  390   2              
  391   2              // 监听按键操作
  392   2              if (key3 == 0) // 下一项
  393   2              {
  394   3                  delay_ms(10);
  395   3                  while (key3 == 0);
  396   3                  delay_ms(10);
  397   3                  flag++;
  398   3                  // 如果到达菜单底部，则翻页到下一页
  399   3                  if (flag > MENU_SIZE) {
  400   4                      flag = 1; // 重置指针
  401   4                      page = (page == 1) ? 2 : 1; // 切换到下一页
  402   4                  }
  403   3              }
  404   2              if (key1 == 0) // 上一项
  405   2              {
  406   3                  delay_ms(10);
  407   3                  while (key1 == 0);
  408   3                  delay_ms(10);
  409   3                  flag--;
  410   3                  // 如果在第一页按上一页，翻至第二页
  411   3                  if (flag == 0 && page == 1) {
  412   4                      flag = MENU_SIZE + 1; // 调整指针位置到第二页底部
  413   4                      page = 2; // 切换到第二页
  414   4                  }
  415   3                  // 如果在第二页按上一页，返回到第一页
  416   3                  else if (flag == 0 && page == 2) {
  417   4                      flag = MENU_SIZE; // 调整指针位置到第一页底部
  418   4                      page = 1; // 切换到第一页
  419   4                  }
  420   3              } 
  421   2              
  422   2              // 更新光标位置
  423   2              for (i = 0; i < MENU_SIZE; i++)
  424   2              {
  425   3                  if (i + 1 == flag)
  426   3                      oled_p8x16str(0, i * 2, "->");  // 光标指示当前选中项
*** WARNING C188 IN LINE 426 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  427   3                  else
  428   3                      oled_p8x16str(0, i * 2, "   ");
*** WARNING C188 IN LINE 428 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  429   3              } 
  430   2          }
  431   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3229     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        46     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
C251 COMPILER V5.60.0,  menu                                                               24/03/24  10:06:24  PAGE 8   

  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       172     ------
End of Module Information.


C251 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
