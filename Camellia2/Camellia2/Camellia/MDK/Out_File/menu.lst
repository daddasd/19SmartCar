C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE menu
OBJECT MODULE PLACED IN .\Out_File\menu.obj
COMPILER INVOKED BY: E:\Keil5C251\C251\BIN\C251.EXE ..\USER\Hardware\menu.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BRO
                    -WSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\U
                    -SER\inc;..\USER\src;..\USER\Hardware;..\USER\Hardware) DEBUG PRINT(.\Out_File\menu.lst) TABS(2) OBJECT(.\Out_File\menu.o
                    -bj) 

stmt  level    source

    1          #include <menu.h>
    2          #include "zf_gpio.h"
    3          #include "SEEKFREE_OLED.h"
    4          #include "zf_delay.h"
    5          #include "myconfig.h"
    6          
    7          #define MENU_SIZE 4
    8          #define INTERVAL_TIME 500
    9          //位置环外环
   10          
   11          
   12          //--
   13          //  @brief      起始菜单显示一些初始值
   14          //  @param      void    
   15          //  @return     1 按KEY2跳转一级菜单      
   16          //--
   17          int Show_AllVal(int flag1)
   18          {
   19   1          int flag = flag1;
   20   1          while (flag == 0)
   21   1          {
   22   2              NORMALIZATION_TRACKING_ADC(1.2, 1.5);
   23   2              show_val();  // 显示测得数据 
   24   2              
   25   2              if (key2 == 0) // 按下跳转到一级菜单
   26   2              {
   27   3                  delay_ms(10);
   28   3                  while (key2 == 0);
   29   3                  delay_ms(10);
   30   3                  oled_fill(0x00); // 清屏
   31   3                  flag = 1;
   32   3                  return 1;
   33   3              }
   34   2          }
   35   1          return 1;
   36   1      }
   37          
   38          //--
   39          //  @brief      一级菜单
   40          //  @param      void    
   41          //  @return     1 按KEY2跳转一级菜单      
   42          //--
   43          int First_menu(void)
   44          {
   45   1        int flag = 1;
   46   1        oled_p6x8str(25,0,"Set_Element"); //调整元素
   47   1        oled_p6x8str(25,1,"Set_Motor_PI"); //设置电机pi
   48   1        oled_p6x8str(25,2,"Set_Wh_Nh_PD"); //设置内外环pd
   49   1        oled_p6x8str(25,3,"Set_Speed"); //设置速度
   50   1        oled_p6x8str(25,4,"Show_Val"); //显示基础值
   51   1        oled_p6x8str(25,5,"Car_Star"); //小车启动
   52   1        while(1)
   53   1        {
   54   2          if(key3==0) // 下一项
   55   2          {
   56   3            delay_ms(10);
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 2   

   57   3            while(key3==0);
   58   3            delay_ms(10);
   59   3            flag++;
   60   3            if(flag == 7) flag = 1;
   61   3          }
   62   2          if(key1==0) // 上一项
   63   2          {
   64   3            delay_ms(10);
   65   3            while(key1==0);
   66   3            delay_ms(10);
   67   3            flag--;
   68   3            if(flag == 0) flag = 6;
   69   3          }
   70   2          if(key2 == 0) //确定
   71   2          {
   72   3            delay_ms(10);
   73   3            while(key2 ==0);
   74   3            delay_ms(10);
   75   3            oled_fill(0x00); //清屏
   76   3            return flag; // 返回选择的选项
   77   3          }
   78   2          if(key4 == 0) //返回上级
   79   2          {
   80   3            delay_ms(10);
   81   3            while(key4 ==0);
   82   3            delay_ms(10);
   83   3            oled_fill(0x00); //清屏
   84   3            return 0; 
   85   3          }
   86   2          switch(flag) //光标移动
   87   2          {
   88   3            case 1:
   89   3            {
   90   4              oled_p6x8str(0,0,"-->"); 
   91   4              oled_p6x8str(0,1,"   "); 
   92   4              oled_p6x8str(0,2,"   ");
   93   4              oled_p6x8str(0,3,"   ");
   94   4              oled_p6x8str(0,4,"   ");
   95   4              oled_p6x8str(0,5,"   ");
   96   4            }break;
   97   3            case 2:
   98   3            {
   99   4              oled_p6x8str(0,0,"   "); 
  100   4              oled_p6x8str(0,1,"-->"); 
  101   4              oled_p6x8str(0,2,"   ");
  102   4              oled_p6x8str(0,3,"   ");
  103   4              oled_p6x8str(0,4,"   ");
  104   4              oled_p6x8str(0,5,"   ");
  105   4            }break;
  106   3            case 3:
  107   3            {
  108   4              oled_p6x8str(0,0,"   "); 
  109   4              oled_p6x8str(0,1,"   "); 
  110   4              oled_p6x8str(0,2,"-->");
  111   4              oled_p6x8str(0,3,"   ");
  112   4              oled_p6x8str(0,4,"   ");
  113   4              oled_p6x8str(0,5,"   ");
  114   4            }break;
  115   3            case 4:
  116   3            {
  117   4              oled_p6x8str(0,0,"   "); 
  118   4              oled_p6x8str(0,1,"   "); 
  119   4              oled_p6x8str(0,2,"   ");
  120   4              oled_p6x8str(0,3,"-->");
  121   4              oled_p6x8str(0,4,"   ");
  122   4              oled_p6x8str(0,5,"   ");
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 3   

  123   4            }break;
  124   3            case 5:
  125   3            {
  126   4              oled_p6x8str(0,0,"   "); 
  127   4              oled_p6x8str(0,1,"   "); 
  128   4              oled_p6x8str(0,2,"   ");
  129   4              oled_p6x8str(0,3,"   ");
  130   4              oled_p6x8str(0,4,"-->");
  131   4              oled_p6x8str(0,5,"   ");
  132   4            }break;
  133   3            case 6:
  134   3            {
  135   4              oled_p6x8str(0,0,"   "); 
  136   4              oled_p6x8str(0,1,"   "); 
  137   4              oled_p6x8str(0,2,"   ");
  138   4              oled_p6x8str(0,3,"   ");
  139   4              oled_p6x8str(0,4,"   ");
  140   4              oled_p6x8str(0,5,"-->");
  141   4            }break;
  142   3          }
  143   2        }
  144   1      }
  145          
  146          //--
  147          //  @brief      二级元素顺序菜单
  148          //  @param      void    
  149          //  @return     0 退出二级菜单    
  150          //--
  151          
  152          
  153          
  154          int Second_Element_menu(void)
  155          {
  156   1          int flag = 1,i = 0,Order = 0,k =0;
  157   1          int menu_order[MENU_SIZE] = {0}; // 用于存储菜单项的顺序
  158   1          
  159   1          oled_p8x16str(25, 0, "L_YuanH");  // 左圆环
  160   1          oled_p8x16str(25, 2, "R_YuanH");  // 右圆环
  161   1          oled_p8x16str(25, 4, "PoDao");    // 坡道
  162   1          oled_p8x16str(25, 6, "LuZhang");      // 路障
  163   1          
  164   1          while (1)
  165   1          {
  166   2              if (key3 == 0) // 下一项
  167   2              {
  168   3                  delay_ms(10);
  169   3                  while (key3 == 0);
  170   3                  delay_ms(10);
  171   3                  flag++;
  172   3                  if (flag == MENU_SIZE + 1) flag = 1;
  173   3              }
  174   2              if (key1 == 0) // 上一项
  175   2              {
  176   3                  delay_ms(10);
  177   3                  while (key1 == 0);
  178   3                  delay_ms(10);
  179   3                  flag--;
  180   3                  if (flag == 0) flag = MENU_SIZE;
  181   3              }
  182   2              if (key2 == 0) // 确定
  183   2              {
  184   3                  delay_ms(10);
  185   3                  while (key2 == 0);
  186   3                  delay_ms(10);
  187   3                  Order++;
  188   3                  if(Order == 5){
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 4   

  189   4                    for(k=0;k<4;k++)
  190   4                    {
  191   5                      Element_Order[k]=menu_order[k];
  192   5                    }
  193   4                    oled_fill(0x00); //清屏
  194   4                    return 0;  //返回上一级
  195   4                  }
  196   3                  menu_order[flag-1] = Order;
  197   3              } 
  198   2              if(key4 == 0) //返回上级
  199   2              {
  200   3                delay_ms(10);
  201   3                while(key4 ==0);
  202   3                delay_ms(10);
  203   3                oled_fill(0x00); //清屏
  204   3                return 0; // 返回选择的选项
  205   3              }
  206   2              // 更新光标位置和显示顺序
  207   2              for (i = 0; i < MENU_SIZE; i++)
  208   2              {
  209   3                  if (i + 1 == flag)
  210   3                      oled_p8x16str(0, i*2, "-->");  // 光标指示当前选中项
*** WARNING C188 IN LINE 210 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  211   3                  else
  212   3                      oled_p8x16str(0, i*2, "   ");
*** WARNING C188 IN LINE 212 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  213   3                      
  214   3                  // 在菜单项后显示顺序
  215   3                  oled_uint16_px8(80, i*2, menu_order[i]);
*** WARNING C188 IN LINE 215 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  216   3              } 
  217   2        }
  218   1      }
  219          
  220          //--
  221          //  @brief      二级调节电机PI菜单
  222          //  @param      void    
  223          //  @return     0 退出二级菜单    
  224          //--
  225          
  226          int Second_Motor_menu(void)
  227          {
  228   1          int flag = 0, Val_add_lose = 1, i = 0, count = 0;
  229   1          int16 long_press_delay = 0;
  230   1          int pree_delay = 0;
  231   1          float x = 0.005;
  232   1          
  233   1          oled_p8x16str(20, 0, "M_P"); 
  234   1          oled_printf_float_px8(50, 0, Motor_P, 2, 4); // 电机P
  235   1          oled_p8x16str(20, 2, "M_I"); 
  236   1          oled_printf_float_px8(50, 2, Motor_I, 2, 4); // 电机I
  237   1          oled_p8x16str(20, 4, "Add");   // 加值
  238   1          oled_p8x16str(20, 6, "Val");   // 加几倍或者减几倍
  239   1          
  240   1          while (1)
  241   1          {
  242   2              if (key3 == 0) // 下一项
  243   2              {
  244   3                  delay_ms(10);
  245   3                  while (key3 == 0);
  246   3                  delay_ms(10);
  247   3                  flag++;
  248   3                  if (flag == 5) flag = 1;
  249   3              }
  250   2              if (key1 == 0) // 上一项
  251   2              {
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 5   

  252   3                  delay_ms(10);
  253   3                  while (key1 == 0);
  254   3                  delay_ms(10);
  255   3                  flag--;
  256   3                  if (flag == 0) flag = 4;
  257   3              } 
  258   2              if (key2 == 0) // 确定
  259   2              {
  260   3                  delay_ms(10);
  261   3                  long_press_delay = 0;
  262   3                  
  263   3                  while (key2 == 0)
  264   3                  {
  265   4                      delay_ms(10);
  266   4                      long_press_delay += 10;
  267   4                      
  268   4                      if (long_press_delay >= INTERVAL_TIME - pree_delay)
  269   4                      {
  270   5                          if (flag == 1)
  271   5                          {
  272   6                              oled_printf_float_px8(50, 0, Motor_P, 2, 4);
  273   6                              Motor_P = Motor_P + x * Val_add_lose;
  274   6                          }
  275   5                          if (flag == 2)
  276   5                          {
  277   6                              Motor_I = Motor_I + x * Val_add_lose;
  278   6                              oled_printf_float_px8(50, 2, Motor_I, 2, 4);
  279   6                          }
  280   5                          pree_delay += 150;
  281   5                          if (pree_delay > 1000) pree_delay = 1000;
  282   5                          long_press_delay = 0;
  283   5                      }
  284   4                  }
  285   3                  delay_ms(10);
  286   3                  if (long_press_delay < 800)
  287   3                  {
  288   4                      pree_delay = 0;
  289   4                      if (flag == 1)
  290   4                      {
  291   5                          oled_printf_float_px8(50, 0, Motor_P, 2, 4);
  292   5                          Motor_P = Motor_P + x * Val_add_lose;
  293   5                      }
  294   4                      if (flag == 2)
  295   4                      {
  296   5                          Motor_I = Motor_I + x * Val_add_lose;
  297   5                          oled_printf_float_px8(50, 2, Motor_I, 2, 4);
  298   5                      }
  299   4                      if (flag == 3)
  300   4                      {
  301   5                          if (count == 0)
  302   5                          {
  303   6                              oled_p8x16str(20, 4, "    ");   // 减值
  304   6                              oled_p8x16str(20, 4, "Lose");   // 减值
  305   6                              Val_add_lose = -1;
  306   6                              count = 1;
  307   6                          }
  308   5                          else if (count == 1)
  309   5                          {
  310   6                              oled_p8x16str(20, 4, "    ");   // 加值
  311   6                              oled_p8x16str(20, 4, "Add");    // 加值
  312   6                              Val_add_lose = 1;
  313   6                              count = 0;
  314   6                          }
  315   5                      }
  316   4                      if (flag == 4)
  317   4                      {
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 6   

  318   5                          x = x + 0.001 * Val_add_lose;
  319   5                          oled_printf_float_px8(50, 6, x, 1, 4);
  320   5                      }
  321   4                  }
  322   3              } 
  323   2              if (key4 == 0)  // 返回
  324   2              {
  325   3                  delay_ms(10);
  326   3                  while (key4 == 0);
  327   3                  delay_ms(10);
  328   3                  oled_fill(0x00); // 清屏
  329   3                  return 0; // 返回选择的选项
  330   3              }
  331   2              for (i = 0; i < 4; i++)
  332   2              {
  333   3                  if (i + 1 == flag)
  334   3                      oled_p8x16str(0, i*2, "->");  // 光标指示当前选中项
*** WARNING C188 IN LINE 334 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  335   3                  else
  336   3                      oled_p8x16str(0, i*2, "  ");
*** WARNING C188 IN LINE 336 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  337   3              } 
  338   2          }
  339   1      }
  340          //--
  341          //  @brief      二级调节内外环PD菜单
  342          //  @param      void    
  343          //  @return     0 退出二级菜单    
  344          //--
  345          // 定义菜单大小
  346          
  347          // 定义菜单大小
  348          #define MENU_SIZE 4
  349          
  350          
  351          
  352          int Second__NWHuan_menu(void)
  353          {
  354   1          int flag = 1, i = 0,Val_add_lose=1,count=-1,flag1=-1;
  355   1          float x =1,x1=0.005;
  356   1          uint16 long_press_delay=0,pree_delay=0;
  357   1          int page = 1; // 用于跟踪当前所在页面
  358   1          int page1 = 1;
  359   1          if(page == 1)
  360   1          {
  361   2                  oled_fill(0x00);
  362   2          }
  363   1          while (1)
  364   1          {
  365   2              // 监听按键操作
  366   2              if (key3 == 0) // 下一项
  367   2              {
  368   3                  delay_ms(10);
  369   3                  while (key3 == 0);
  370   3                  delay_ms(10);
  371   3                  flag++;
  372   3                  // 如果到达菜单底部，则翻页到下一页
  373   3                  if (flag > MENU_SIZE) {
  374   4                      flag = 1; // 重置指针
  375   4                      page = (page == 1) ? 2 : 1; // 切换到下一页
  376   4                  }
  377   3              }
  378   2              if (key1 == 0) // 上一项
  379   2              {
  380   3                  delay_ms(10);
  381   3                  while (key1 == 0);
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 7   

  382   3                  delay_ms(10);
  383   3                  flag--;
  384   3                  // 如果在第一页按上一页，翻至第二页
  385   3                  if (flag == 0 && page == 1) {
  386   4                      flag = MENU_SIZE + 1; // 调整指针位置到第二页底部
  387   4                      page = 2; // 切换到第二页
  388   4                  }
  389   3                  // 如果在第二页按上一页，返回到第一页
  390   3                  else if (flag == 0 && page == 2) {
  391   4                      flag = MENU_SIZE; // 调整指针位置到第一页底部
  392   4                      page = 1; // 切换到第一页
  393   4                  }
  394   3              } 
  395   2              //----------------------一二页区---------------------------//
  396   2              if (page == 1)  //第一页
  397   2              {
  398   3                  if(page1==1)
  399   3                  {
  400   4                      oled_fill(0x00);
  401   4                      page1=2;
  402   4                      oled_p8x16str(22, 0, "N_P");  
  403   4                      oled_printf_float_px8(45, 0, Nh_P, 2, 3); // 内环P
  404   4                      oled_p8x16str(22, 2, "N_D");  
  405   4                      oled_printf_float_px8(45, 2, Nh_D, 2, 3); // 内环D
  406   4                      oled_p8x16str(22, 4, "W_P");  
  407   4                      oled_printf_float_px8(45, 4, Wh_P, 3, 2); // 外环P
  408   4                      oled_p8x16str(22, 6, "W_D");  
  409   4                      oled_printf_float_px8(45, 6, Wh_D, 3, 2); // 外环D
  410   4                  }
  411   3              } 
  412   2              else if (page == 2) //第二页
  413   2              {
  414   3                  if(page1==2)
  415   3                  {
  416   4                      oled_fill(0x00);
  417   4                      page1=1;  
  418   4                     // oled_p8x16str(22, 0, "Add");
  419   4                      oled_p8x16str(22, 2, "W_Val");
  420   4                      oled_p8x16str(22, 4, "N_Val");            
  421   4                  }
  422   3              }
  423   2      //----------------------一二页区---------------------------//
  424   2              if (key2 == 0&&page==1) // 确定并且在第一页
  425   2              {
  426   3                  delay_ms(10);
  427   3                  long_press_delay = 0;
  428   3                  while (key2 == 0)
  429   3                  {
  430   4                      delay_ms(10);
  431   4                      long_press_delay += 10;
  432   4                      if (long_press_delay >= INTERVAL_TIME - pree_delay)
  433   4                      {
  434   5                          if (flag == 1) {
  435   6                              oled_printf_float_px8(45, 0, Nh_P, 2, 3);
  436   6                              Nh_P = Nh_P + x1 * Val_add_lose;
  437   6                          } else if (flag == 2) {
  438   6                              oled_printf_float_px8(45, 2, Nh_D, 2, 3);
  439   6                              Nh_D = Nh_D + x1 * Val_add_lose;
  440   6                          } else if (flag == 3) {
  441   6                              Wh_P = Wh_P + x* Val_add_lose;
  442   6                              oled_printf_float_px8(45, 4, Wh_P, 3, 2);
  443   6                          } else if (flag == 4) {
  444   6                              Wh_D = Wh_D + x * Val_add_lose;
  445   6                              oled_printf_float_px8(45, 6, Wh_D, 3, 2);
  446   6                          }
  447   5                          pree_delay += 150;
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 8   

  448   5                          if (pree_delay > 1000) pree_delay = 1000;
  449   5                          long_press_delay = 0;
  450   5                      }
  451   4                  }
  452   3                  delay_ms(10);
  453   3                  if (long_press_delay < 800)
  454   3                  {
  455   4                      pree_delay = 0;
  456   4                      switch(flag)
  457   4                      {
  458   5                          case 1:
  459   5                          {
  460   6                              oled_printf_float_px8(45, 0, Nh_P, 2, 3);
  461   6                              Nh_P = Nh_P + x1 * Val_add_lose;
  462   6                          }break;
  463   5                          case 2:
  464   5                          {
  465   6                              oled_printf_float_px8(45, 2, Nh_D, 2, 3);
  466   6                              Nh_D = Nh_D + x1 * Val_add_lose;
  467   6                          }break;
  468   5                          case 3:
  469   5                          {
  470   6                              Wh_P = Wh_P + x * Val_add_lose;
  471   6                              oled_printf_float_px8(45, 4, Wh_P, 3, 2);
  472   6                          }break;
  473   5                          case 4:
  474   5                          {
  475   6                              Wh_D = Wh_D + x * Val_add_lose;
  476   6                              oled_printf_float_px8(45, 6, Wh_D, 3, 2);
  477   6                          }break;
  478   5                      }   
  479   4      
  480   4                  }
  481   3              } 
  482   2              if (key2 == 0&&page==2) // 确定并且在第一页
  483   2              {
  484   3                  delay_ms(10);
  485   3                  while(key2==0);
  486   3                  delay_ms(10);
  487   3                  if (flag == 1)//并且在第二页 第一列add与lose
  488   3                  {
  489   4                      count ++;
  490   4                      if(count==3)count=0;
  491   4                      if (count == 0)
  492   4                      {
  493   5                          oled_p8x16str(22, 0, "    ");   // 减值
  494   5                          oled_p8x16str(22, 0, "Lose");   // 减值
  495   5                          Val_add_lose = -1;
  496   5                          flag1++;
  497   5                      }
  498   4                      else if (count == 1)
  499   4                      {
  500   5                          oled_p8x16str(22, 0, "    ");   // 加值
  501   5                          oled_p8x16str(22, 0, "Add");    // 加值
  502   5                          Val_add_lose = 1;
  503   5                      }
  504   4                      
  505   4                  }
  506   3                  if (flag == 2)
  507   3                  {
  508   4                      x = x + 0.5 * Val_add_lose;
  509   4                      oled_printf_float_px8(50, 2, x, 3, 1);
  510   4                  }
  511   3                  if(flag==3)
  512   3                  {
  513   4                      x1 = x1 + 0.005 * Val_add_lose;
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 9   

  514   4                      oled_printf_float_px8(50, 4, x1, 1, 3);                    
  515   4                  }
  516   3              }
  517   2              if (key4 == 0)  // 返回
  518   2              {
  519   3                  delay_ms(10);
  520   3                  while (key4 == 0);
  521   3                  delay_ms(10);
  522   3                  oled_fill(0x00); // 清屏
  523   3                  return 0; // 返回选择的选项
  524   3              }
  525   2              // 更新光标位置
  526   2              for (i = 0; i < MENU_SIZE; i++)
  527   2              {
  528   3                  if (i + 1 == flag)
  529   3                      oled_p8x16str(0, i * 2, "->");  // 光标指示当前选中项
*** WARNING C188 IN LINE 529 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  530   3                  else
  531   3                      oled_p8x16str(0, i * 2, "  ");
*** WARNING C188 IN LINE 531 OF ..\USER\Hardware\menu.c: 'parameter 2': value truncated
  532   3              } 
  533   2          }
  534   1      }
  535          
  536          
  537          //--
  538          //  @brief      二级调节速度菜单
  539          //  @param      void    
  540          //  @return     0 退出二级菜单    
  541          //--
  542          
  543          int Second__Speed_menu(void)
  544          {
  545   1          oled_fill(0x00);
  546   1          oled_p8x16str(0, 0, "Speed");
  547   1          oled_uint16_px8(45,0, speed); 
  548   1          while(1)
  549   1          {
  550   2              if(key2==0)
  551   2              {
  552   3                  delay_ms(10);
  553   3                  while(key2==0);
  554   3                  delay_ms(10);
  555   3                  speed=speed+1;
  556   3                  oled_uint16_px8(45,0, speed); 
  557   3              } 
  558   2              if(key3==0)
  559   2              {
  560   3                  delay_ms(10);
  561   3                  while(key3==0);
  562   3                  delay_ms(10);
  563   3                  speed=speed-1;
  564   3                  oled_uint16_px8(45,0, speed); 
  565   3              }
  566   2              if (key4 == 0)  // 返回
  567   2              {
  568   3                  delay_ms(10);
  569   3                  while (key4 == 0);
  570   3                  delay_ms(10);
  571   3                  oled_fill(0x00); // 清屏
  572   3                  return 0; // 返回选择的选项
  573   3              }
  574   2          }
  575   1      }
  576          
  577          
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 10  

  578          //--
  579          //  @brief      二级显示数据菜单
  580          //  @param      void    
  581          //  @return     0 退出二级菜单    
  582          //--
  583          
  584          int Show_Val_Menu(void)
  585          {
  586   1          while(1)
  587   1          {
  588   2              NORMALIZATION_TRACKING_ADC(1,1);
  589   2              show_val();
  590   2              mpu6050_get_gyro();
  591   2              if (key4 == 0)  // 返回
  592   2              {
  593   3                  delay_ms(10);
  594   3                  while (key4 == 0);
  595   3                  delay_ms(10);
  596   3                  oled_fill(0x00); // 清屏
  597   3                  return 0; // 返回选择的选项
  598   3              }
  599   2          }
  600   1      }
  601          //--
  602          //  @brief      二级启动菜单
  603          //  @param      void    
  604          //  @return     0 退出二级菜单    
  605          //--
  606          
  607          int CarStart_Menu(void)
  608          {
  609   1          while(1)
  610   1          {
  611   2              oled_p8x16str(0, 0, "Car_Start");
  612   2              if(key2==0)
  613   2              {
  614   3                  delay_ms(10);
  615   3                  while (key2==0)
  616   3                  {
  617   4                      delay_ms(10);
  618   4                      return 1;// 小车启动
  619   4                  }
  620   3              }      
  621   2              if (key4 == 0)  // 返回
  622   2              {
  623   3                  delay_ms(10);
  624   3                  while (key4 == 0);
  625   3                  delay_ms(10);
  626   3                  oled_fill(0x00); // 清屏
  627   3                  return 0; // 返回选择的选项
  628   3              } 
  629   2          }
  630   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4683     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        64     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
C251 COMPILER V5.60.0,  menu                                                               12/04/24  18:31:27  PAGE 11  

  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       188     ------
End of Module Information.


C251 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
