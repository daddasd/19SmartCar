C251 COMPILER V5.60.0,  Inductance                                                         06/05/24  21:46:46  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Inductance
OBJECT MODULE PLACED IN .\Out_File\Inductance.obj
COMPILER INVOKED BY: E:\Keil5C251\C251\BIN\C251.EXE ..\USER\Hardware\Inductance.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEE
                    -D) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\COD
                    -E;..\USER\inc;..\USER\src;..\USER\Hardware;..\USER\Hardware) DEBUG PRINT(.\Out_File\Inductance.lst) TABS(2) OBJECT(.\Out
                    -_File\Inductance.obj) 

stmt  level    source

    1          /*
    2           * @Description: 
    3           * @Author: Yzhi
    4           * @Date: 2023-11-17 20:11:13
    5           * @LastEditTime: 2023-11-28 17:34:59
    6           * @LastEditors: Yzhi
    7           */
    8          #include "myconfig.h"
    9          
   10          
   11          #define filter_n 9//数组长度
   12          
   13          
   14          uint16 Left_Val=0,Right_Val=0;
   15          int16 ad_sum=0;
   16          int16 ad_diff=0;
   17          uint16 ad_value[7][10]={0};//原始数据
   18          uint16 R1,R2,R3,L1,L2,L3,M1;//滤波之后的电感值
   19          uint16 L1_NOR_ADC=0,R1_NOR_ADC=0,L2_NOR_ADC=0,R2_NOR_ADC=0,L3_NOR_ADC=0,R3_NOR_ADC=0,M1_NOR_ADC=0;
   20          float NOR_VAL[7]={0};
   21          float AD_NOR_VAL[7]={0}; //归一化值
   22          int16 Inductance_Error=0; //电感误差
   23          uint16 ADC_MIN[7]={156,252,160,150,153,180,149};
   24          uint16 ADC_MAX[7]={3020,2620,2620,2620,2600,2600,2600}; //测出的电感最大，与最小值从左到右
   25          int bug=0;
   26          /**
   27          *  @brief      ADC采集初始化
   28          *  @param      void
   29          *  @return     void         
   30          **/
   31          
   32          void Inductance_Init(void)
   33          {
   34   1        adc_init(ADC_P11, ADC_SYSclk_DIV_2);
   35   1        adc_init(ADC_P10, ADC_SYSclk_DIV_2);
   36   1        adc_init(ADC_P06, ADC_SYSclk_DIV_2);        
   37   1          adc_init(ADC_P04, ADC_SYSclk_DIV_2);    
   38   1        adc_init(ADC_P03, ADC_SYSclk_DIV_2);
   39   1        adc_init(ADC_P02, ADC_SYSclk_DIV_2);
   40   1          adc_init(ADC_P01, ADC_SYSclk_DIV_2);
   41   1        adc_init(ADC_P00, ADC_SYSclk_DIV_2);
   42   1      }
   43          /**
   44           * @brief 快速开方
   45           * 
   46           * @param f 被开方数
   47           * @return float 
   48           */
   49          float sq(float number)
   50          {  
   51   1        long i;
   52   1        float x, y;
   53   1        const float f = 1.5F;
   54   1        
   55   1        x = number * 0.5F;
   56   1        y = number;
C251 COMPILER V5.60.0,  Inductance                                                         06/05/24  21:46:46  PAGE 2   

   57   1        i = * ( long * ) &y;
   58   1        i = 0x5f3759df - ( i >> 1 );
   59   1        y = * ( float * ) &i;
   60   1        y = y * ( f - ( x * y * y ) );
   61   1        y = y * ( f - ( x * y * y ) );
   62   1        return number * y;
   63   1      }
   64          
   65          
   66          
   67          /**
   68          *  @brief      归一化处理电感值并循迹控制
   69          *  @param      I1,I2,加权系数,
   70          *  @return     void         
   71          **/
   72          int16 NORMALIZATION_TRACKING_ADC(float I1,float I2)  
   73          {
   74   1        int i = 0, j = 0, k = 0, temp = 0;
   75   1        int ad_sum1[7] = {0};
   76   1        uint16 ad_valu1[7] = {0};
   77   1        for (i = 0; i < 10; i++) // 读取十次电感
   78   1        {
   79   2            ad_value[0][i] = adc_once(ADC_P11, ADC_12BIT);
   80   2            ad_value[1][i] = adc_once(ADC_P10, ADC_12BIT);
   81   2            ad_value[2][i] = adc_once(ADC_P06, ADC_12BIT);
   82   2            ad_value[3][i] = adc_once(ADC_P01, ADC_12BIT);
   83   2            ad_value[4][i] = adc_once(ADC_P04, ADC_12BIT);
   84   2            ad_value[5][i] = adc_once(ADC_P03, ADC_12BIT);
   85   2            ad_value[6][i] = adc_once(ADC_P02, ADC_12BIT);
   86   2            bug=adc_once(ADC_P00, ADC_12BIT);
   87   2        }
   88   1      
   89   1        /*=========================冒泡排序升序==========================*/
   90   1        for (i = 0; i < 7; i++)
   91   1        {
   92   2            for (j = 0; j < 10 - 1; j++)
   93   2            {
   94   3                for (k = 0; k < 10 - 1 - j; k++)
   95   3                {
   96   4                    if (ad_value[i][k] > ad_value[i][k + 1]) // 前面的比后面的大，则进行交换
   97   4                    {
   98   5                        temp = ad_value[i][k + 1];
   99   5                        ad_value[i][k + 1] = ad_value[i][k];
  100   5                        ad_value[i][k] = temp;
  101   5                    }
  102   4                }
  103   3            }
  104   2        }
  105   1      
  106   1        /*===========================中值滤波=================================*/
  107   1        for (i = 0; i < 7; i++) // 求中间八项的和
  108   1        {
  109   2            for (k = 0; k < 9; k++) // 舍弃最大值和最小值，只取中间8项
  110   2            {
  111   3                ad_sum1[i] += ad_value[i][k];
  112   3            }
  113   2            ad_valu1[i] = ad_sum1[i] / 8;
  114   2        }
  115   1      
  116   1        /*=========================赋值各个电感==============================*/
  117   1        L1 = ad_valu1[0];
  118   1        L2 = ad_valu1[1];
  119   1        L3 = ad_valu1[2];
  120   1        M1 = ad_valu1[3];
  121   1        R3 = ad_valu1[4];
  122   1        R2 = ad_valu1[5];
C251 COMPILER V5.60.0,  Inductance                                                         06/05/24  21:46:46  PAGE 3   

  123   1        R1 = ad_valu1[6];
  124   1        
  125   1      
  126   1        
  127   1        
  128   1      
  129   1        NOR_VAL[0]=(float)(L1-ADC_MIN[0])/(float)(ADC_MAX[0]-ADC_MIN[0]);
  130   1        NOR_VAL[1]=(float)(L2-ADC_MIN[1])/(float)(ADC_MAX[1]-ADC_MIN[1]);
  131   1        NOR_VAL[2]=(float)(L3-ADC_MIN[2])/(float)(ADC_MAX[2]-ADC_MIN[2]);
  132   1        NOR_VAL[3]=(float)(M1-ADC_MIN[3])/(float)(ADC_MAX[3]-ADC_MIN[3]);
  133   1        NOR_VAL[4]=(float)(R3-ADC_MIN[4])/(float)(ADC_MAX[4]-ADC_MIN[4]);
  134   1        NOR_VAL[5]=(float)(R2-ADC_MIN[5])/(float)(ADC_MAX[5]-ADC_MIN[5]);
  135   1        NOR_VAL[6]=(float)(R1-ADC_MIN[6])/(float)(ADC_MAX[6]-ADC_MIN[6]);
  136   1        
  137   1        for(i = 0 ; i<7;i++)
  138   1        {
  139   2          if(NOR_VAL[i]<=0.0)
  140   2          {
  141   3            NOR_VAL[i]=0.001;
  142   3          }
  143   2          if(NOR_VAL[i]>1.0)
  144   2          {
  145   3            NOR_VAL[i]=1.0;
  146   3          }   
  147   2          AD_NOR_VAL[i]=NOR_VAL[i]*100;
  148   2        }
  149   1        
  150   1        
  151   1        L1_NOR_ADC=AD_NOR_VAL[0];
  152   1        L2_NOR_ADC=AD_NOR_VAL[1];
  153   1        L3_NOR_ADC=AD_NOR_VAL[2];
  154   1        M1_NOR_ADC=AD_NOR_VAL[3];
  155   1        R3_NOR_ADC=AD_NOR_VAL[4];
  156   1        R2_NOR_ADC=AD_NOR_VAL[5];
  157   1        R1_NOR_ADC=AD_NOR_VAL[6];
  158   1        
  159   1        L1_NOR_ADC=L1_NOR_ADC;
*** WARNING C138 IN LINE 159 OF ..\USER\Hardware\Inductance.c: expression with possibly no effect
  160   1        R1_NOR_ADC=I1*R1_NOR_ADC; 
  161   1        L2_NOR_ADC=0.65*L2_NOR_ADC;
  162   1        R2_NOR_ADC=1.25*R2_NOR_ADC;
  163   1      
  164   1        Left_Val=sq(L1_NOR_ADC*L1_NOR_ADC+L2_NOR_ADC*L2_NOR_ADC);
  165   1        Right_Val=sq(R1_NOR_ADC*R1_NOR_ADC+R2_NOR_ADC*R2_NOR_ADC);
  166   1        ad_sum=Left_Val+Right_Val;
  167   1        ad_diff=Left_Val-Right_Val;
  168   1        if(ad_sum>35)
  169   1        {
  170   2          Inductance_Error=(ad_diff <<7)/(ad_sum+1);
  171   2          if(Inductance_Error<40) 
  172   2            Inductance_Error = Inductance_Error * 0.78;
  173   2          else if(Inductance_Error > 75)
  174   2            Inductance_Error = Inductance_Error * 1.2;
  175   2        }
  176   1        //Inductance_Error=ad_diff;
  177   1        return Inductance_Error; //放大128倍
  178   1      }
*** WARNING C47 IN LINE 72 OF ..\USER\Hardware\Inductance.c: 'I2': unreferenced parameter
  179          
  180          /**
  181          *  @brief      显示测量值
  182          *  @param      void
  183          *  @return     void         
  184          **/
  185          
  186          void show_val(void)
C251 COMPILER V5.60.0,  Inductance                                                         06/05/24  21:46:46  PAGE 4   

  187          {
  188   1      //-----------------oled显示电感值----------------------//
  189   1        oled_p6x8str(0,0,"L1:");
  190   1        oled_uint16(15,0,L1_NOR_ADC);
  191   1      
  192   1        oled_p6x8str(70,0,"R1:");
  193   1        oled_uint16(85,0,R1_NOR_ADC);
  194   1      
  195   1        oled_p6x8str(0,1,"L2:");
  196   1        oled_uint16(15,1,L2_NOR_ADC);
  197   1      
  198   1        oled_p6x8str(70,1,"R2:");
  199   1        oled_uint16(85,1,R2_NOR_ADC);
  200   1      
  201   1        oled_p6x8str(0,2,"L3:");
  202   1        oled_uint16(15,2,L3_NOR_ADC);
  203   1      
  204   1        oled_p6x8str(70,2,"R3:");
  205   1        oled_uint16(85,2,R3_NOR_ADC);
  206   1      
  207   1        oled_p6x8str(0,3,"Err:");
  208   1        oled_int16(20,3,Inductance_Error);
  209   1        
  210   1        oled_p6x8str(70,3,"M1:");
  211   1        oled_uint16(85,3,M1_NOR_ADC);
  212   1      ////-----------------陀螺仪角速度------------------------//
  213   1      
  214   1        oled_p6x8str(0,4,"gyro_z:");
  215   1        oled_printf_float(45, 4,Get_Angle(), 5, 6);
  216   1        oled_int16(0,5,L_Pulse);
  217   1        oled_int16(60,5,R_Pulse);
  218   1        oled_int16(0,6,dir_out);
  219   1        oled_int16(60,6,nh_out);
  220   1      //-----------------TOF距离------------------------//
  221   1      //  if(dl1a_finsh_flag)
  222   1      //  {
  223   1      //    dl1a_finsh_flag = 0;
  224   1      //    oled_int16(60,6,dl1a_distance_mm);
  225   1      //  }
  226   1      
  227   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2225     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       324     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       391     ------
End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
