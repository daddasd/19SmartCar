C251 COMPILER V5.60.0,  Inductance                                                         28/05/24  12:09:38  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Inductance
OBJECT MODULE PLACED IN .\Out_File\Inductance.obj
COMPILER INVOKED BY: E:\Keil5C251\C251\BIN\C251.EXE ..\USER\Hardware\Inductance.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEE
                    -D) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\COD
                    -E;..\USER\inc;..\USER\src;..\USER\Hardware;..\USER\Hardware) DEBUG PRINT(.\Out_File\Inductance.lst) TABS(2) OBJECT(.\Out
                    -_File\Inductance.obj) 

stmt  level    source

    1          /*
    2           * @Description:
    3           * @Author: Yzhi
    4           * @Date: 2023-11-17 20:11:13
    5           * @LastEditTime: 2023-11-28 17:34:59
    6           * @LastEditors: Yzhi
    7           */
    8          #include "myconfig.h"
    9          
   10          #define filter_n 9 // 数组长度
   11          
   12          uint16 Left_Val = 0, Right_Val = 0;
   13          int16 ad_sum = 0;
   14          int16 ad_diff = 0;
   15          uint16 ad_value[5][10] = {0};    // 原始数据
   16          uint16 R1, R2, R3, L1, L2, L3, M1; // 滤波之后的电感值
   17          uint16 L1_NOR_ADC = 0, R1_NOR_ADC = 0, L2_NOR_ADC = 0, R2_NOR_ADC = 0, L3_NOR_ADC = 0, R3_NOR_ADC = 0, M1
             -_NOR_ADC = 0;
   18          float NOR_VAL[5] = {0};
   19          float AD_NOR_VAL[5] = {0};  // 归一化值
   20          int16 Inductance_Error = 0; // 电感误差
   21          uint16 ADC_MIN[5] = {156, 252,150,180, 149};
   22          uint16 ADC_MAX[5] = {3020, 3520,  3520,  3520, 3020}; // 测出的电感最大，与最小值从左到右
   23          
   24          int bug = 0;
   25          
   26          float I1 = 1.7;
   27          float I2 = 1.7;  //电感权值
   28          /**
   29           *  @brief      ADC采集初始化
   30           *  @param      void
   31           *  @return     void
   32           **/
   33          
   34          void Inductance_Init(void)
   35          {
   36   1        adc_init(ADC_P10, ADC_SYSclk_DIV_2);
   37   1        adc_init(ADC_P05, ADC_SYSclk_DIV_2);
   38   1        adc_init(ADC_P06, ADC_SYSclk_DIV_2);
   39   1        adc_init(ADC_P00, ADC_SYSclk_DIV_2);
   40   1        adc_init(ADC_P01, ADC_SYSclk_DIV_2);
   41   1        adc_init(ADC_P02, ADC_SYSclk_DIV_2);
   42   1        adc_init(ADC_P03, ADC_SYSclk_DIV_2);
   43   1        adc_init(ADC_P04, ADC_SYSclk_DIV_2);
   44   1      }
   45          /**
   46           * @brief 快速开方
   47           *
   48           * @param f 被开方数
   49           * @return float
   50           */
   51          float sq(float number)
   52          {
   53   1        long i;
   54   1        float x, y;
   55   1        const float f = 1.5F;
C251 COMPILER V5.60.0,  Inductance                                                         28/05/24  12:09:38  PAGE 2   

   56   1      
   57   1        x = number * 0.5F;
   58   1        y = number;
   59   1        i = *(long *)&y;
   60   1        i = 0x5f3759df - (i >> 1);
   61   1        y = *(float *)&i;
   62   1        y = y * (f - (x * y * y));
   63   1        y = y * (f - (x * y * y));
   64   1        return number * y;
   65   1      }
   66          
   67          
   68          //5电感循迹
   69          /**
   70           *  @brief      归一化处理电感值并循迹控制
   71           *  @param      I1,I2,加权系数,
   72           *  @return     void
   73           **/
   74          int16 NORMALIZATION_TRACKING_ADC(void)
   75          {
   76   1        int i = 0, j = 0, k = 0, temp = 0;
   77   1        int ad_sum1[5] = {0};
   78   1        uint16 ad_valu1[5] = {0};
   79   1        for (i = 0; i < 10; i++) // 读取十次电感
   80   1        {
   81   2          ad_value[0][i] = adc_once(ADC_P05, ADC_12BIT);
   82   2          ad_value[1][i] = adc_once(ADC_P06, ADC_12BIT);
   83   2          ad_value[2][i] = adc_once(ADC_P01, ADC_12BIT);
   84   2          ad_value[3][i] = adc_once(ADC_P03, ADC_12BIT);
   85   2          ad_value[4][i] = adc_once(ADC_P02, ADC_12BIT);
   86   2          bug = adc_once(ADC_P04, ADC_12BIT);
   87   2        }
   88   1      
   89   1        /*=========================冒泡排序升序==========================*/
   90   1        for (i = 0; i < 5; i++)
   91   1        {
   92   2          for (j = 0; j < 10 - 1; j++)
   93   2          {
   94   3            for (k = 0; k < 10 - 1 - j; k++)
   95   3            {
   96   4              if (ad_value[i][k] > ad_value[i][k + 1]) // 前面的比后面的大，则进行交换
   97   4              {
   98   5                temp = ad_value[i][k + 1];
   99   5                ad_value[i][k + 1] = ad_value[i][k];
  100   5                ad_value[i][k] = temp;
  101   5              }
  102   4            }
  103   3          }
  104   2        }
  105   1      
  106   1        /*===========================中值滤波=================================*/
  107   1        for (i = 0; i < 5; i++) // 求中间八项的和
  108   1        {
  109   2          for (k = 0; k < 9; k++) // 舍弃最大值和最小值，只取中间8项
  110   2          {
  111   3            ad_sum1[i] += ad_value[i][k];
  112   3          }
  113   2          ad_valu1[i] = ad_sum1[i] / 8;
  114   2        }
  115   1      
  116   1        /*=========================赋值各个电感==============================*/
  117   1        L1 = ad_valu1[0];
  118   1        L2 = ad_valu1[1];
  119   1        M1 = ad_valu1[2];
  120   1        R2 = ad_valu1[3];
  121   1        R1 = ad_valu1[4];
C251 COMPILER V5.60.0,  Inductance                                                         28/05/24  12:09:38  PAGE 3   

  122   1      
  123   1        NOR_VAL[0] = (float)(L1 - ADC_MIN[0]) / (float)(ADC_MAX[0] - ADC_MIN[0]);
  124   1        NOR_VAL[1] = (float)(L2 - ADC_MIN[1]) / (float)(ADC_MAX[1] - ADC_MIN[1]);
  125   1        NOR_VAL[2] = (float)(M1 - ADC_MIN[2]) / (float)(ADC_MAX[2] - ADC_MIN[2]);
  126   1        NOR_VAL[3] = (float)(R2 - ADC_MIN[3]) / (float)(ADC_MAX[3] - ADC_MIN[3]);
  127   1        NOR_VAL[4] = (float)(R1 - ADC_MIN[4]) / (float)(ADC_MAX[4] - ADC_MIN[4]);
  128   1      
  129   1        for (i = 0; i < 5; i++)
  130   1        {
  131   2          if (NOR_VAL[i] <= 0.0)
  132   2          {
  133   3            NOR_VAL[i] = 0.001;
  134   3          }
  135   2          if (NOR_VAL[i] > 1.0)
  136   2          {
  137   3            NOR_VAL[i] = 1.0;
  138   3          }
  139   2          AD_NOR_VAL[i] = NOR_VAL[i] * 100;
  140   2        }
  141   1      
  142   1        L1_NOR_ADC = AD_NOR_VAL[0];
  143   1        L2_NOR_ADC = AD_NOR_VAL[1];
  144   1        M1_NOR_ADC = AD_NOR_VAL[2];
  145   1        R2_NOR_ADC = AD_NOR_VAL[3];
  146   1        R1_NOR_ADC = AD_NOR_VAL[4];
  147   1      
  148   1        L1_NOR_ADC = L1_NOR_ADC;
*** WARNING C138 IN LINE 148 OF ..\USER\Hardware\Inductance.c: expression with possibly no effect
  149   1        L2_NOR_ADC = L2_NOR_ADC*I1;
  150   1        R1_NOR_ADC = R1_NOR_ADC;
*** WARNING C138 IN LINE 150 OF ..\USER\Hardware\Inductance.c: expression with possibly no effect
  151   1        R2_NOR_ADC = R2_NOR_ADC*I2;
  152   1        //动态权重
  153   1        Left_Val = sq(L1_NOR_ADC * L1_NOR_ADC + L2_NOR_ADC * L2_NOR_ADC);
  154   1        Right_Val = sq(R1_NOR_ADC * R1_NOR_ADC + R2_NOR_ADC * R2_NOR_ADC);
  155   1        ad_sum = Left_Val + Right_Val;
  156   1        ad_diff = Left_Val - Right_Val;
  157   1        if (ad_sum > 35)
  158   1        {
  159   2          Inductance_Error = (ad_diff << 7) / ((ad_sum + 1));
  160   2        }
  161   1        // Inductance_Error=ad_diff;
  162   1        return Inductance_Error; // 放大128倍
  163   1      }
  164          
  165          /**
  166           *  @brief      显示测量值
  167           *  @param      void
  168           *  @return     void
  169           **/
  170          
  171          void show_val(void)
  172          {
  173   1        //-----------------oled显示电感值----------------------//
  174   1        oled_p6x8str(0, 0, "L1:");
  175   1        oled_uint16(15, 0, L1_NOR_ADC);
  176   1      
  177   1        oled_p6x8str(70, 0, "R1:");
  178   1        oled_uint16(85, 0, R1_NOR_ADC);
  179   1      
  180   1        oled_p6x8str(0, 1, "L2:");
  181   1        oled_uint16(15, 1, L2_NOR_ADC);
  182   1      
  183   1        oled_p6x8str(70, 1, "R2:");
  184   1        oled_uint16(85, 1, R2_NOR_ADC);
  185   1      
C251 COMPILER V5.60.0,  Inductance                                                         28/05/24  12:09:38  PAGE 4   

  186   1        oled_p6x8str(0, 2, "M1:");
  187   1        oled_uint16(15, 2, M1_NOR_ADC);
  188   1      
  189   1        oled_p6x8str(55, 2, "Err:");
  190   1        oled_int16(80, 2, Inductance_Error);
  191   1      
  192   1        ////-----------------陀螺仪角速度------------------------//
  193   1        oled_p6x8str(0, 3, "G_z");
  194   1        oled_int16(20, 3,mpu6050_gyro_z);
  195   1        oled_p6x8str(60, 3, "Dis");
  196   1        oled_int16(80, 3, dl1a_distance_mm);
  197   1        oled_int16(0, 4, L_Pulse);
  198   1        oled_int16(60, 4, R_Pulse);
  199   1        oled_p6x8str(0,5, "Dir:");
  200   1        oled_int16(30, 5, dir_out);
  201   1        oled_p6x8str(0,6, "PWM:");
  202   1        oled_int16(30, 6, Motor_pid.Motor_Out_Value);
  203   1        //-----------------TOF距离------------------------//
  204   1        //  if(dl1a_finsh_flag)
  205   1        //  {
  206   1        //    dl1a_finsh_flag = 0;
  207   1        //    oled_int16(60,6,dl1a_distance_mm);
  208   1        //  }
  209   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1950     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       256     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       337     ------
End of Module Information.


C251 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
