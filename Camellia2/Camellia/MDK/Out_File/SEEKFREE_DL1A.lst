C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_DL1A
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_DL1A.obj
COMPILER INVOKED BY: E:\Keil5C251\C251\BIN\C251.EXE ..\..\Libraries\seekfree_peripheral\SEEKFREE_DL1A.c XSMALL WARNINGLE
                    -VEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seek
                    -free_peripheral;..\CODE;..\USER\inc;..\USER\src;..\USER\Hardware;..\USER\Hardware) DEBUG PRINT(.\Out_File\SEEKFREE_DL1A.
                    -lst) TABS(2) OBJECT(.\Out_File\SEEKFREE_DL1A.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * COPYRIGHT NOTICE
    3           * Copyright (c) 2021,é€é£ç§‘æŠ€
    4           * All rights reserved.
    5           * æŠ€æœ¯è®¨è®ºQQç¾¤ï¼šä¸€ç¾¤ï¼š179029047(å·²æ»¡)  äºŒç¾¤ï¼š244861897
    6           *
    7           * ä»¥ä¸‹æ‰€æœ‰å†…å®¹ç‰ˆæƒå‡å±é€é£ç§‘æŠ€æ‰€æœ‰ï¼Œæœªç»å…è®¸ä¸å¾—ç”¨äºå•†ä¸šç”¨é€”ï¼Œ
    8           * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åºï¼Œä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ã€‚
    9           *
   10           * @file          DL1A
   11           * @company       æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   12           * @author        é€é£ç§‘æŠ€(QQ3184284598)
   13           * @version       æŸ¥çœ‹docå†…versionæ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   14           * @Software    MDK FOR C251 V5.60
   15           * @Target core   STC32F12K
   16           * @Taobao      https://seekfree.taobao.com/
   17           * @date          2021-08-27
   18           * @note
   19           * æ¥çº¿å®šä¹‰ï¼š
   20           *                   ------------------------------------
   21           *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   22           *                   SCL                 æŸ¥çœ‹ SEEKFREE_DL1A.h ä¸­ DL1A_SCL_PIN   å®å®šä¹‰
   23           *                   SDA                 æŸ¥çœ‹ SEEKFREE_DL1A.h ä¸­ DL1A_SDA_PIN   å®å®šä¹‰
   24           *                    XS                 æŸ¥çœ‹ SEEKFREE_DL1A.h ä¸­ DL1A_XSHUT_PIN å®å®šä¹‰
   25           *                   VCC                 5V ç”µæº
   26           *                   GND                 ç”µæºåœ°
   27           *                   ------------------------------------
   28           ********************************************************************************************************
             -************/
   29          
   30          #include "zf_delay.h"
   31          #include "SEEKFREE_DL1A.h"
   32          
   33          #pragma warning disable = 183
   34          
   35          uint8 dl1a_finsh_flag;
   36          uint16 dl1a_distance_mm;
   37          
   38          #define GET_DL1A_SDA DL1A_SDA_PIN
   39          #define DL1A_SDA_LOW() DL1A_SDA_PIN = 0  // IOå£è¾“å‡ºä½ç”µå¹³
   40          #define DL1A_SDA_HIGH() DL1A_SDA_PIN = 1 // IOå£è¾“å‡ºé«˜ç”µå¹³
   41          
   42          #define DL1A_SCL_LOW() DL1A_SCL_PIN = 0  // IOå£è¾“å‡ºä½ç”µå¹³
   43          #define DL1A_SCL_HIGH() DL1A_SCL_PIN = 1 // IOå£è¾“å‡ºé«˜ç”µå¹³
   44          
   45          #define ack 1    // ä¸»åº”ç­”
   46          #define no_ack 0 // ä»åº”ç­”
   47          
   48          //-------------------------------------------------------------------------------------------------------
             -------------
   49          //  @brief      æ¨¡æ‹ŸIICå»¶æ—¶
   50          //  @return     void
   51          //  @since      v1.0
   52          //  Sample usage:       å¦‚æœIICé€šè®¯å¤±è´¥å¯ä»¥å°è¯•å¢åŠ jçš„å€¼
   53          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 2   

             -------------
   54          static void dl1a_simiic_delay(void)
   55          {
   56   1          uint16 j = DL1A_SOFT_IIC_DELAY;
   57   1          while (j--)
   58   1              ;
   59   1      }
   60          
   61          // å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   62          static void dl1a_simiic_start(void)
   63          {
   64   1          DL1A_SDA_HIGH();
   65   1          DL1A_SCL_HIGH();
   66   1          dl1a_simiic_delay();
   67   1          DL1A_SDA_LOW();
   68   1          dl1a_simiic_delay();
   69   1          DL1A_SCL_LOW();
   70   1      }
   71          
   72          // å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   73          static void dl1a_simiic_stop(void)
   74          {
   75   1          DL1A_SDA_LOW();
   76   1          DL1A_SCL_LOW();
   77   1          dl1a_simiic_delay();
   78   1          DL1A_SCL_HIGH();
   79   1          dl1a_simiic_delay();
   80   1          DL1A_SDA_HIGH();
   81   1          dl1a_simiic_delay();
   82   1      }
   83          
   84          // ä¸»åº”ç­”(åŒ…å«ack:SDA=0å’Œno_ack:SDA=0)
   85          // å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
   86          static void dl1a_simiic_sendack(unsigned char ack_dat)
   87          {
   88   1          DL1A_SCL_LOW();
   89   1          dl1a_simiic_delay();
   90   1          if (ack_dat)
   91   1              DL1A_SDA_LOW();
   92   1          else
   93   1              DL1A_SDA_HIGH();
   94   1      
   95   1          DL1A_SCL_HIGH();
   96   1          dl1a_simiic_delay();
   97   1          DL1A_SCL_LOW();
   98   1          dl1a_simiic_delay();
   99   1      }
  100          
  101          static int dl1a_sccb_waitack(void)
  102          {
  103   1          DL1A_SCL_LOW();
  104   1      
  105   1          dl1a_simiic_delay();
  106   1      
  107   1          DL1A_SCL_HIGH();
  108   1          dl1a_simiic_delay();
  109   1      
  110   1          if (GET_DL1A_SDA) // åº”ç­”ä¸ºé«˜ç”µå¹³ï¼Œå¼‚å¸¸ï¼Œé€šä¿¡å¤±è´¥
  111   1          {
  112   2      
  113   2              DL1A_SCL_LOW();
  114   2              return 0;
  115   2          }
  116   1      
  117   1          DL1A_SCL_LOW();
  118   1          dl1a_simiic_delay();
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 3   

  119   1          return 1;
  120   1      }
  121          
  122          // å­—èŠ‚å‘é€ç¨‹åº
  123          // å‘é€c(å¯ä»¥æ˜¯æ•°æ®ä¹Ÿå¯æ˜¯åœ°å€)ï¼Œé€å®Œåæ¥æ”¶ä»åº”ç­”
  124          // ä¸è€ƒè™‘ä»åº”ç­”ä½
  125          // å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  126          static void dl1a_send_ch(uint8 c)
  127          {
  128   1          uint8 i = 8;
  129   1          while (i--)
  130   1          {
  131   2              if (c & 0x80)
  132   2                  DL1A_SDA_HIGH(); // SDA è¾“å‡ºæ•°æ®
  133   2              else
  134   2                  DL1A_SDA_LOW();
  135   2              c <<= 1;
  136   2              dl1a_simiic_delay();
  137   2              DL1A_SCL_HIGH(); // SCL æ‹‰é«˜ï¼Œé‡‡é›†ä¿¡å·
  138   2              dl1a_simiic_delay();
  139   2              DL1A_SCL_LOW(); // SCL æ—¶é’Ÿçº¿æ‹‰ä½
  140   2          }
  141   1          dl1a_sccb_waitack();
  142   1      }
  143          
  144          // å­—èŠ‚æ¥æ”¶ç¨‹åº
  145          // æ¥æ”¶å™¨ä»¶ä¼ æ¥çš„æ•°æ®ï¼Œæ­¤ç¨‹åºåº”é…åˆ|ä¸»åº”ç­”å‡½æ•°|ä½¿ç”¨
  146          // å†…éƒ¨ä½¿ç”¨ï¼Œç”¨æˆ·æ— éœ€è°ƒç”¨
  147          static uint8 dl1a_read_ch(uint8 ack_x)
  148          {
  149   1          uint8 i;
  150   1          uint8 c;
  151   1          c = 0;
  152   1          DL1A_SCL_LOW();
  153   1          dl1a_simiic_delay();
  154   1          DL1A_SDA_HIGH();
  155   1      
  156   1          for (i = 0; i < 8; i++)
  157   1          {
  158   2              dl1a_simiic_delay();
  159   2              DL1A_SCL_LOW(); // ç½®æ—¶é’Ÿçº¿ä¸ºä½ï¼Œå‡†å¤‡æ¥æ”¶æ•°æ®ä½
  160   2              dl1a_simiic_delay();
  161   2              DL1A_SCL_HIGH(); // ç½®æ—¶é’Ÿçº¿ä¸ºé«˜ï¼Œä½¿æ•°æ®çº¿ä¸Šæ•°æ®æœ‰æ•ˆ
  162   2              dl1a_simiic_delay();
  163   2              c <<= 1;
  164   2              if (GET_DL1A_SDA)
  165   2              {
  166   3                  c += 1; // è¯»æ•°æ®ä½ï¼Œå°†æ¥æ”¶çš„æ•°æ®å­˜c
  167   3              }
  168   2          }
  169   1      
  170   1          DL1A_SCL_LOW();
  171   1          dl1a_simiic_delay();
  172   1          dl1a_simiic_sendack(ack_x);
  173   1      
  174   1          return c;
  175   1      }
  176          
  177          //-------------------------------------------------------------------------------------------------------
             -------------
  178          //  @brief      æ¨¡æ‹ŸIICå†™æ•°æ®åˆ°è®¾å¤‡å¯„å­˜å™¨å‡½æ•°
  179          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  180          //  @param      reg       å¯„å­˜å™¨åœ°å€
  181          //  @param      dat       å†™å…¥çš„æ•°æ®
  182          //  @return     void
  183          //  @since      v1.0
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 4   

  184          //  Sample usage:
  185          //-------------------------------------------------------------------------------------------------------
             -------------
  186          static void dl1a_simiic_write_dats(uint8 dev_add, uint8 *dat, uint32 len)
  187          {
  188   1          dl1a_simiic_start();
  189   1          dl1a_send_ch((dev_add << 1) | 0x00); // å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  190   1          while (len--)
  191   1          {
  192   2              dl1a_send_ch(*dat++); // å‘é€éœ€è¦å†™å…¥çš„æ•°æ®
  193   2          }
  194   1      
  195   1          dl1a_simiic_stop();
  196   1      }
  197          
  198          //-------------------------------------------------------------------------------------------------------
             -------------
  199          //  @brief      æ¨¡æ‹ŸIICå†™æ•°æ®åˆ°è®¾å¤‡å¯„å­˜å™¨å‡½æ•°
  200          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  201          //  @param      reg       å¯„å­˜å™¨åœ°å€
  202          //  @param      dat       å†™å…¥çš„æ•°æ®
  203          //  @return     void
  204          //  @since      v1.0
  205          //  Sample usage:
  206          //-------------------------------------------------------------------------------------------------------
             -------------
  207          static void dl1a_simiic_write_reg(uint8 dev_add, uint8 reg, uint8 dat)
  208          {
  209   1          dl1a_simiic_start();
  210   1          dl1a_send_ch((dev_add << 1) | 0x00); // å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  211   1          dl1a_send_ch(reg);                   // å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  212   1          dl1a_send_ch(dat);                   // å‘é€éœ€è¦å†™å…¥çš„æ•°æ®
  213   1          dl1a_simiic_stop();
  214   1      }
  215          
  216          //-------------------------------------------------------------------------------------------------------
             -------------
  217          //  @brief      æ¨¡æ‹ŸIICä»è®¾å¤‡å¯„å­˜å™¨è¯»å–æ•°æ®
  218          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  219          //  @param      reg       å¯„å­˜å™¨åœ°å€
  220          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  221          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®
  222          //  @since      v1.0
  223          //  Sample usage:
  224          //-------------------------------------------------------------------------------------------------------
             -------------
  225          static uint8 dl1a_simiic_read_reg(uint8 dev_add, uint8 reg)
  226          {
  227   1          uint8 dat;
  228   1          dl1a_simiic_start();
  229   1          dl1a_send_ch((dev_add << 1) | 0x00); // å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  230   1          dl1a_send_ch(reg);                   // å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  231   1      
  232   1          dl1a_simiic_start();
  233   1          dl1a_send_ch((dev_add << 1) | 0x01); // å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  234   1          dat = dl1a_read_ch(no_ack);          // è¯»å–æ•°æ®
  235   1          dl1a_simiic_stop();
  236   1      
  237   1          return dat;
  238   1      }
  239          
  240          //-------------------------------------------------------------------------------------------------------
             -------------
  241          //  @brief      æ¨¡æ‹ŸIICè¯»å–å¤šå­—èŠ‚æ•°æ®
  242          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  243          //  @param      reg       å¯„å­˜å™¨åœ°å€
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 5   

  244          //  @param      dat_add     æ•°æ®ä¿å­˜çš„åœ°å€æŒ‡é’ˆ
  245          //  @param      num       è¯»å–å­—èŠ‚æ•°é‡
  246          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  247          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®
  248          //  @since      v1.0
  249          //  Sample usage:
  250          //-------------------------------------------------------------------------------------------------------
             -------------
  251          static void dl1a_simiic_read_regs(uint8 dev_add, uint8 reg, uint8 *dat_add, uint32 num)
  252          {
  253   1          dl1a_simiic_start();
  254   1          dl1a_send_ch((dev_add << 1) | 0x00); // å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  255   1          dl1a_send_ch(reg);                   // å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  256   1      
  257   1          dl1a_simiic_start();
  258   1          dl1a_send_ch((dev_add << 1) | 0x01); // å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  259   1          while (--num)
  260   1          {
  261   2              *dat_add = dl1a_read_ch(ack); // è¯»å–æ•°æ®
  262   2              dat_add++;
  263   2          }
  264   1          *dat_add = dl1a_read_ch(no_ack); // è¯»å–æ•°æ®
  265   1          dl1a_simiic_stop();
  266   1      }
  267          
  268          //-------------------------------------------------------------------------------------------------------
             -------------
  269          //  @brief      æ¨¡æ‹ŸIICè¯»å–å¤šå­—èŠ‚æ•°æ®
  270          //  @param      dev_add     è®¾å¤‡åœ°å€(ä½ä¸ƒä½åœ°å€)
  271          //  @param      reg       å¯„å­˜å™¨åœ°å€
  272          //  @param      dat_add     æ•°æ®ä¿å­˜çš„åœ°å€æŒ‡é’ˆ
  273          //  @param      num       è¯»å–å­—èŠ‚æ•°é‡
  274          //  @param      type      é€‰æ‹©é€šä¿¡æ–¹å¼æ˜¯IIC  è¿˜æ˜¯ SCCB
  275          //  @return     uint8     è¿”å›å¯„å­˜å™¨çš„æ•°æ®
  276          //  @since      v1.0
  277          //  Sample usage:
  278          //-------------------------------------------------------------------------------------------------------
             -------------
  279          static void dl1a_simiic_read_regs_1(uint8 dev_add, uint8 reg, uint8 *dat_add, uint32 num)
  280          {
  281   1          dl1a_simiic_start();
  282   1          dl1a_send_ch((dev_add << 1) | 0x00); // å‘é€å™¨ä»¶åœ°å€åŠ å†™ä½
  283   1          dl1a_send_ch(reg);                   // å‘é€ä»æœºå¯„å­˜å™¨åœ°å€
  284   1      
  285   1          dl1a_simiic_start();
  286   1          dl1a_send_ch((dev_add << 1) | 0x01); // å‘é€å™¨ä»¶åœ°å€åŠ è¯»ä½
  287   1          while (--num)
  288   1          {
  289   2              *dat_add = dl1a_read_ch(ack); // è¯»å–æ•°æ®
  290   2              dat_add++;
  291   2          }
  292   1          *dat_add = dl1a_read_ch(no_ack); // è¯»å–æ•°æ®
  293   1          dl1a_simiic_stop();
  294   1      }
  295          
  296          #define dl1a_write_array(dat, len) (dl1a_simiic_write_dats(DL1A_DEV_ADDR, (dat), (len)))
  297          #define dl1a_write_register(reg, dat) (dl1a_simiic_write_reg(DL1A_DEV_ADDR, (reg), (dat)))
  298          #define dl1a_read_register(reg) (dl1a_simiic_read_reg(DL1A_DEV_ADDR, (reg)))
  299          #define dl1a_read_registers(reg, dat, len) (dl1a_simiic_read_regs(DL1A_DEV_ADDR, (reg), (dat), (len)))
  300          #define dl1a_read_registers_1(reg, dat, len) (dl1a_simiic_read_regs_1(DL1A_DEV_ADDR, (reg), (dat), (len))
             -)
  301          
  302          // è¿™ä¸ªé€Ÿç‡è¡¨ç¤ºä»ç›®æ ‡åå°„å¹¶è¢«è®¾å¤‡æ£€æµ‹åˆ°çš„ä¿¡å·çš„æŒ¯å¹…
  303          // è®¾ç½®æ­¤é™åˆ¶å¯ä»¥ç¡®å®šä¼ æ„Ÿå™¨æŠ¥å‘Šæœ‰æ•ˆè¯»æ•°æ‰€éœ€çš„æœ€å°æµ‹é‡å€¼
  304          // è®¾ç½®ä¸€ä¸ªè¾ƒä½çš„é™åˆ¶å¯ä»¥å¢åŠ ä¼ æ„Ÿå™¨çš„æµ‹é‡èŒƒå›´
  305          // ä½†ä¼¼ä¹ä¹Ÿå¢åŠ äº† <ç”±äºæ¥è‡ªç›®æ ‡ä»¥å¤–çš„ç‰©ä½“çš„ä¸éœ€è¦çš„åå°„å¯¼è‡´> å¾—åˆ°ä¸å‡†ç¡®è¯
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 6   

             -»æ•°çš„å¯èƒ½æ€§
  306          // é»˜è®¤ä¸º 0.25 MCPS å¯é¢„è®¾èŒƒå›´ä¸º 0 - 511.99
  307          #define DL1A_DEFAULT_RATE_LIMIT (0.25)
  308          
  309          // ä»å¯„å­˜å™¨æ•°æ®è§£ç  PCLKs ä¸­ VCSEL (vertical cavity surface emitting laser) çš„è„‰å®½å‘¨æœŸ
  310          #define decode_vcsel_period(reg_val) (((reg_val) + 1) << 1)
  311          
  312          // ä» PCLK ä¸­çš„ VCSEL å‘¨æœŸè®¡ç®—å®å‘¨æœŸ (ä»¥ *çº³ç§’ä¸ºå•ä½)
  313          // PLL_period_ps = 1655
  314          // macro_period_vclks = 2304
  315          #define calc_macro_period(vcsel_period_pclks) ((((uint32)2304 * (vcsel_period_pclks) * 1655) + 500) / 100
             -0)
  316          
  317          //-------------------------------------------------------------------------------------------------------
             -------------
  318          // å‡½æ•°ç®€ä»‹     è·å–è®¾å¤‡ SPAD ä¿¡æ¯
  319          // å‚æ•°è¯´æ˜     index           ç´¢å¼•
  320          // å‚æ•°è¯´æ˜     type            ç±»å‹å€¼
  321          // è¿”å›å‚æ•°     uint8           æ˜¯å¦æˆåŠŸ 0-æˆåŠŸ 1-å¤±è´¥
  322          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_spad_info(index, type_is_aperture);
  323          // å¤‡æ³¨ä¿¡æ¯
  324          //-------------------------------------------------------------------------------------------------------
             -------------
  325          static uint8 dl1a_get_spad_info(uint8 *index, uint8 *type_is_aperture)
  326          {
  327   1          uint8 tmp = 0;
  328   1          uint8 return_state = 0;
  329   1          volatile uint16 loop_count = 0;
  330   1      
  331   1          do
  332   1          {
  333   2              dl1a_write_register(0x80, 0x01);
  334   2              dl1a_write_register(0xFF, 0x01);
  335   2              dl1a_write_register(0x00, 0x00);
  336   2      
  337   2              dl1a_write_register(0xFF, 0x06);
  338   2              dl1a_read_registers(0x83, &tmp, 1);
  339   2              dl1a_write_register(0x83, tmp | 0x04);
  340   2              dl1a_write_register(0xFF, 0x07);
  341   2              dl1a_write_register(0x81, 0x01);
  342   2      
  343   2              dl1a_write_register(0x80, 0x01);
  344   2      
  345   2              dl1a_write_register(0x94, 0x6b);
  346   2              dl1a_write_register(0x83, 0x00);
  347   2      
  348   2              tmp = 0x00;
  349   2              while (tmp != 0x10)
  350   2              {
  351   3                  dl1a_read_registers(0x83, &tmp, 1);
  352   3                  loop_count++;
  353   3                  if (loop_count == DL1A_TIMEOUT_COUNT)
  354   3                  {
  355   4                      return_state = 1;
  356   4                      break;
  357   4                  }
  358   3              }
  359   2      
  360   2              if (return_state)
  361   2              {
  362   3                  break;
  363   3              }
  364   2              dl1a_write_register(0x83, 0x01);
  365   2              dl1a_read_registers(0x92, &tmp, 1);
  366   2      
  367   2              *index = tmp & 0x7f;
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 7   

  368   2              *type_is_aperture = (tmp >> 7) & 0x01;
  369   2      
  370   2              dl1a_write_register(0x81, 0x00);
  371   2              dl1a_write_register(0xFF, 0x06);
  372   2              dl1a_read_registers(0x83, &tmp, 1);
  373   2              dl1a_write_register(0x83, tmp);
  374   2              dl1a_write_register(0xFF, 0x01);
  375   2              dl1a_write_register(0x00, 0x01);
  376   2      
  377   2              dl1a_write_register(0xFF, 0x00);
  378   2              dl1a_write_register(0x80, 0x00);
  379   2          } while (0);
  380   1      
  381   1          return return_state;
  382   1      }
  383          
  384          //-------------------------------------------------------------------------------------------------------
             -------------
  385          // å‡½æ•°ç®€ä»‹     å°†è¶…æ—¶æ•°å€¼ä» MCLKs è½¬æ¢åˆ°å¯¹åº”çš„ ms
  386          // å‚æ•°è¯´æ˜     timeout_period_mclks    è¶…æ—¶å‘¨æœŸ MCLKs
  387          // å‚æ•°è¯´æ˜     vcsel_period_pclks      PCLK å€¼
  388          // è¿”å›å‚æ•°     uint32                  è¿”å›è¶…æ—¶æ•°å€¼
  389          // ä½¿ç”¨ç¤ºä¾‹     dl1a_timeout_mclks_to_microseconds(timeout_period_mclks, vcsel_period_pclks);
  390          // å¤‡æ³¨ä¿¡æ¯     å°†åºåˆ—æ­¥éª¤è¶…æ—¶ä»å…·æœ‰ç»™å®š VCSEL å‘¨æœŸçš„ MCLK (ä»¥ PCLK ä¸ºå•ä½)è½¬æ¢ä
             -¸ºå¾®ç§’
  391          //-------------------------------------------------------------------------------------------------------
             -------------
  392          static uint32 dl1a_timeout_mclks_to_microseconds(uint16 timeout_period_mclks, uint8 vcsel_period_pclks)
  393          {
  394   1          uint32 macro_period_ns = calc_macro_period(vcsel_period_pclks);
  395   1      
  396   1          return ((timeout_period_mclks * macro_period_ns) + (macro_period_ns / 2)) / 1000;
  397   1      }
  398          
  399          //-------------------------------------------------------------------------------------------------------
             -------------
  400          // å‡½æ•°ç®€ä»‹     å°†è¶…æ—¶æ•°å€¼ä» ms è½¬æ¢åˆ°å¯¹åº”çš„ MCLKs
  401          // å‚æ•°è¯´æ˜     timeout_period_us   è¶…æ—¶å‘¨æœŸ å¾®ç§’å•ä½
  402          // å‚æ•°è¯´æ˜     vcsel_period_pclks  PCLK å€¼
  403          // è¿”å›å‚æ•°     uint32              è¿”å›è¶…æ—¶æ•°å€¼
  404          // ä½¿ç”¨ç¤ºä¾‹     dl1a_timeout_microseconds_to_mclks(timeout_period_us, vcsel_period_pclks);
  405          // å¤‡æ³¨ä¿¡æ¯     å°†åºåˆ—æ­¥éª¤è¶…æ—¶ä»å¾®ç§’è½¬æ¢ä¸ºå…·æœ‰ç»™å®š VCSEL å‘¨æœŸçš„ MCLK (ä»¥ PCLK ä¸
             -ºå•ä½)
  406          //-------------------------------------------------------------------------------------------------------
             -------------
  407          static uint32 dl1a_timeout_microseconds_to_mclks(uint32 timeout_period_us, uint8 vcsel_period_pclks)
  408          {
  409   1          uint32 macro_period_ns = calc_macro_period(vcsel_period_pclks);
  410   1      
  411   1          return (((timeout_period_us * 1000) + (macro_period_ns / 2)) / macro_period_ns);
  412   1      }
  413          
  414          //-------------------------------------------------------------------------------------------------------
             -------------
  415          // å‡½æ•°ç®€ä»‹     å¯¹è¶…æ—¶æ•°å€¼è¿›è¡Œè§£ç 
  416          // å‚æ•°è¯´æ˜     reg_val         è¶…æ—¶æ—¶é•¿ å¯„å­˜å™¨å€¼
  417          // è¿”å›å‚æ•°     uint16          è¿”å›è¶…æ—¶æ•°å€¼
  418          // ä½¿ç”¨ç¤ºä¾‹     dl1a_decode_timeout(reg_val);
  419          // å¤‡æ³¨ä¿¡æ¯     ä»å¯„å­˜å™¨å€¼è§£ç  MCLK ä¸­çš„åºåˆ—æ­¥éª¤è¶…æ—¶
  420          //-------------------------------------------------------------------------------------------------------
             -------------
  421          static uint16 dl1a_decode_timeout(uint16 reg_val)
  422          {
  423   1          // æ ¼å¼: (LSByte * 2 ^ MSByte) + 1
  424   1          return (uint16)((reg_val & 0x00FF) << (uint16)((reg_val & 0xFF00) >> 8)) + 1;
  425   1      }
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 8   

  426          
  427          //-------------------------------------------------------------------------------------------------------
             -------------
  428          // å‡½æ•°ç®€ä»‹     å¯¹è¶…æ—¶æ•°å€¼è¿›è¡Œç¼–ç 
  429          // å‚æ•°è¯´æ˜     timeout_mclks   è¶…æ—¶æ—¶é•¿ -MCLKs å€¼
  430          // è¿”å›å‚æ•°     uint16          è¿”å›ç¼–ç å€¼
  431          // ä½¿ç”¨ç¤ºä¾‹     dl1a_encode_timeout(timeout_mclks);
  432          // å¤‡æ³¨ä¿¡æ¯     åœ¨ MCLK ä¸­å¯¹è¶…æ—¶çš„åºåˆ—æ­¥éª¤è¶…æ—¶å¯„å­˜å™¨å€¼è¿›è¡Œç¼–ç 
  433          //-------------------------------------------------------------------------------------------------------
             -------------
  434          static uint16 dl1a_encode_timeout(uint16 timeout_mclks)
  435          {
  436   1          uint32 ls_byte = 0;
  437   1          uint16 ms_byte = 0;
  438   1          uint16 return_data = 0;
  439   1      
  440   1          if (timeout_mclks > 0)
  441   1          {
  442   2              // æ ¼å¼: (LSByte * 2 ^ MSByte) + 1
  443   2              ls_byte = timeout_mclks - 1;
  444   2              while ((ls_byte & 0xFFFFFF00) > 0)
  445   2              {
  446   3                  ls_byte >>= 1;
  447   3                  ms_byte++;
  448   3              }
  449   2              return_data = (ms_byte << 8) | (ls_byte & 0xFF);
  450   2          }
  451   1          return return_data;
  452   1      }
  453          
  454          //-------------------------------------------------------------------------------------------------------
             -------------
  455          // å‡½æ•°ç®€ä»‹     è·å–åºåˆ—æ­¥éª¤ä½¿èƒ½è®¾ç½®
  456          // å‚æ•°è¯´æ˜     enables         åºåˆ—ä½¿èƒ½æ­¥éª¤ç»“æ„ä½“
  457          // è¿”å›å‚æ•°     void
  458          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_sequence_step_enables(enables);
  459          // å¤‡æ³¨ä¿¡æ¯
  460          //-------------------------------------------------------------------------------------------------------
             -------------
  461          static void dl1a_get_sequence_step_enables(dl1a_sequence_enables_step_struct *enables)
  462          {
  463   1          uint8 sequence_config = 0;
  464   1          dl1a_read_registers(DL1A_SYSTEM_SEQUENCE_CONFIG, &sequence_config, 1);
  465   1      
  466   1          enables->tcc = (sequence_config >> 4) & 0x1;
  467   1          enables->dss = (sequence_config >> 3) & 0x1;
  468   1          enables->msrc = (sequence_config >> 2) & 0x1;
  469   1          enables->pre_range = (sequence_config >> 6) & 0x1;
  470   1          enables->final_range = (sequence_config >> 7) & 0x1;
  471   1      }
  472          
  473          //-------------------------------------------------------------------------------------------------------
             -------------
  474          // å‡½æ•°ç®€ä»‹     è·å–è„‰å†²å‘¨æœŸ
  475          // å‚æ•°è¯´æ˜     type            é¢„é‡ç¨‹ç±»å‹
  476          // è¿”å›å‚æ•°     uint8           è¿”å›çš„å‘¨æœŸå€¼
  477          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_vcsel_pulse_period(DL1A_VCSEL_PERIOD_PER_RANGE);
  478          // å¤‡æ³¨ä¿¡æ¯     åœ¨ PCLKs ä¸­è·å–ç»™å®šå‘¨æœŸç±»å‹çš„ VCSEL è„‰å†²å‘¨æœŸ
  479          //-------------------------------------------------------------------------------------------------------
             -------------
  480          static uint8 dl1a_get_vcsel_pulse_period(dl1a_vcsel_period_type_enum type)
  481          {
  482   1          uint8 data_buffer = 0;
  483   1          if (type == DL1A_VCSEL_PERIOD_PER_RANGE)
  484   1          {
  485   2              dl1a_read_registers(DL1A_PRE_RANGE_CONFIG_VCSEL_PERIOD, &data_buffer, 1);
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 9   

  486   2              data_buffer = decode_vcsel_period(data_buffer);
  487   2          }
  488   1          else if (type == DL1A_VCSEL_PERIOD_FINAL_RANGE)
  489   1          {
  490   2              dl1a_read_registers(DL1A_FINAL_RANGE_CONFIG_VCSEL_PERIOD, &data_buffer, 1);
  491   2              data_buffer = decode_vcsel_period(data_buffer);
  492   2          }
  493   1          else
  494   1          {
  495   2              data_buffer = 255;
  496   2          }
  497   1          return data_buffer;
  498   1      }
  499          
  500          //-------------------------------------------------------------------------------------------------------
             -------------
  501          // å‡½æ•°ç®€ä»‹     è·å–åºåˆ—æ­¥éª¤è¶…æ—¶è®¾ç½®
  502          // å‚æ•°è¯´æ˜     enables         åºåˆ—ä½¿èƒ½æ­¥éª¤ç»“æ„ä½“
  503          // å‚æ•°è¯´æ˜     timeouts        åºåˆ—è¶…æ—¶æ­¥éª¤ç»“æ„ä½“
  504          // è¿”å›å‚æ•°     void
  505          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_sequence_step_timeouts(enables, timeouts);
  506          // å¤‡æ³¨ä¿¡æ¯     è·å–æ‰€æœ‰è¶…æ—¶è€Œä¸ä»…ä»…æ˜¯è¯·æ±‚çš„è¶…æ—¶ å¹¶ä¸”è¿˜å­˜å‚¨ä¸­é—´å€¼
  507          //-------------------------------------------------------------------------------------------------------
             -------------
  508          static void dl1a_get_sequence_step_timeouts(dl1a_sequence_enables_step_struct const *enables, dl1a_sequen
             -ce_timeout_step_struct *timeouts)
  509          {
  510   1          uint8 reg_buffer[2];
  511   1          uint16 reg16_buffer = 0;
  512   1      
  513   1          timeouts->pre_range_vcsel_period_pclks = dl1a_get_vcsel_pulse_period(DL1A_VCSEL_PERIOD_PER_RANGE);
  514   1      
  515   1          dl1a_read_registers(DL1A_MSRC_CONFIG_TIMEOUT_MACROP, reg_buffer, 1);
  516   1          timeouts->msrc_dss_tcc_mclks = reg_buffer[0] + 1;
  517   1          timeouts->msrc_dss_tcc_us = dl1a_timeout_mclks_to_microseconds(timeouts->msrc_dss_tcc_mclks, (uint8)t
             -imeouts->pre_range_vcsel_period_pclks);
  518   1      
  519   1          dl1a_read_registers(DL1A_PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI, reg_buffer, 2);
  520   1          reg16_buffer = ((uint16)reg_buffer[0] << 8) | reg_buffer[1];
  521   1          timeouts->pre_range_mclks = dl1a_decode_timeout(reg16_buffer);
  522   1          timeouts->pre_range_us = dl1a_timeout_mclks_to_microseconds(timeouts->pre_range_mclks, (uint8)timeout
             -s->pre_range_vcsel_period_pclks);
  523   1      
  524   1          timeouts->final_range_vcsel_period_pclks = dl1a_get_vcsel_pulse_period(DL1A_VCSEL_PERIOD_FINAL_RANGE)
             -;
  525   1      
  526   1          dl1a_read_registers(DL1A_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI, reg_buffer, 2);
  527   1          reg16_buffer = ((uint16)reg_buffer[0] << 8) | reg_buffer[1];
  528   1          timeouts->final_range_mclks = dl1a_decode_timeout(reg16_buffer);
  529   1      
  530   1          if (enables->pre_range)
  531   1          {
  532   2              timeouts->final_range_mclks -= timeouts->pre_range_mclks;
  533   2          }
  534   1      
  535   1          timeouts->final_range_us = dl1a_timeout_mclks_to_microseconds(timeouts->final_range_mclks, (uint8)tim
             -eouts->final_range_vcsel_period_pclks);
  536   1      }
  537          
  538          //-------------------------------------------------------------------------------------------------------
             -------------
  539          // å‡½æ•°ç®€ä»‹     æ‰§è¡Œå•æ¬¡å‚è€ƒæ ¡å‡†
  540          // å‚æ•°è¯´æ˜     vhv_init_byte   é¢„è®¾æ ¡å‡†å€¼
  541          // è¿”å›å‚æ•°     uint8           æ“ä½œæ˜¯å¦æˆåŠŸ 0-æˆåŠŸ 1-å¤±è´¥
  542          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_vcsel_pulse_period(DL1A_VCSEL_PERIOD_PER_RANGE);
  543          // å¤‡æ³¨ä¿¡æ¯     åœ¨ PCLKs ä¸­è·å–ç»™å®šå‘¨æœŸç±»å‹çš„ VCSEL è„‰å†²å‘¨æœŸ
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 10  

  544          //-------------------------------------------------------------------------------------------------------
             -------------
  545          static uint8 dl1a_perform_single_ref_calibration(uint8 vhv_init_byte)
  546          {
  547   1          uint8 return_state = 0;
  548   1          uint8 data_buffer = 0;
  549   1          volatile uint16 loop_count = 0;
  550   1          do
  551   1          {
  552   2              dl1a_write_register(DL1A_SYSRANGE_START, 0x01 | vhv_init_byte);
  553   2              dl1a_read_registers(DL1A_MSRC_CONFIG_TIMEOUT_MACROP, &data_buffer, 1);
  554   2              while ((data_buffer & 0x07) == 0)
  555   2              {
  556   3                  if (loop_count > 0x8fe0)
  557   3                  {
  558   4                      return_state = 1;
  559   4                      break;
  560   4                  }
  561   3                  if (loop_count++ % 0x10 == 0)
  562   3                  {
  563   4                      dl1a_read_registers(DL1A_MSRC_CONFIG_TIMEOUT_MACROP, &data_buffer, 1);
  564   4                  }
  565   3              }
  566   2              if (return_state)
  567   2              {
  568   3                  break;
  569   3              }
  570   2              dl1a_write_register(DL1A_SYSTEM_INTERRUPT_CLEAR, 0x01);
  571   2              dl1a_write_register(DL1A_SYSRANGE_START, 0x00);
  572   2          } while (0);
  573   1      
  574   1          return return_state;
  575   1      }
  576          
  577          //-------------------------------------------------------------------------------------------------------
             -------------
  578          // å‡½æ•°ç®€ä»‹     è®¾ç½®æµ‹é‡å®šæ—¶é¢„ç®— (ä»¥å¾®ç§’ä¸ºå•ä½)
  579          // å‚æ•°è¯´æ˜     budget_us       è®¾å®šçš„æµ‹é‡å…è®¸çš„æ—¶é—´
  580          // è¿”å›å‚æ•°     uint8           æ“ä½œç»“æœ 0-æˆåŠŸ 1-å¤±è´¥
  581          // ä½¿ç”¨ç¤ºä¾‹     dl1a_set_measurement_timing_budget(measurement_timing_budget_us);
  582          // å¤‡æ³¨ä¿¡æ¯     è¿™æ˜¯ä¸€æ¬¡æµ‹é‡å…è®¸çš„æ—¶é—´
  583          //              å³åœ¨æµ‹è·åºåˆ—çš„å­æ­¥éª¤ä¹‹é—´åˆ†é…æ—¶é—´é¢„ç®—
  584          //              æ›´é•¿çš„æ—¶é—´é¢„ç®—å…è®¸æ›´ç²¾ç¡®çš„æµ‹é‡
  585          //              å¢åŠ ä¸€ä¸ªNå€çš„é¢„ç®—å¯ä»¥å‡å°‘ä¸€ä¸ªsqrt(N)å€çš„èŒƒå›´æµ‹é‡æ ‡å‡†åå·®
  586          //              é»˜è®¤ä¸º33æ¯«ç§’ æœ€å°å€¼ä¸º20 ms
  587          //-------------------------------------------------------------------------------------------------------
             -------------
  588          static uint8 dl1a_set_measurement_timing_budget(uint32 budget_us)
  589          {
  590   1          uint8 return_state = 0;
  591   1          uint8 data_buffer[3];
  592   1          uint16 dat = 0;
  593   1          uint32 used_budget_us;
  594   1          uint32 final_range_timeout_us;
  595   1          uint16 final_range_timeout_mclks;
  596   1      
  597   1          dl1a_sequence_enables_step_struct enables;
  598   1          dl1a_sequence_timeout_step_struct timeouts;
  599   1      
  600   1          do
  601   1          {
  602   2              if (budget_us < DL1A_MIN_TIMING_BUDGET)
  603   2              {
  604   3                  return_state = 1;
  605   3                  break;
  606   3              }
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 11  

  607   2      
  608   2              used_budget_us = DL1A_SET_START_OVERHEAD + DL1A_END_OVERHEAD;
  609   2              dl1a_get_sequence_step_enables(&enables);
  610   2              dl1a_get_sequence_step_timeouts(&enables, &timeouts);
  611   2      
  612   2              if (enables.tcc)
  613   2              {
  614   3                  used_budget_us += (timeouts.msrc_dss_tcc_us + DL1A_TCC_OVERHEAD);
  615   3              }
  616   2      
  617   2              if (enables.dss)
  618   2              {
  619   3                  used_budget_us += 2 * (timeouts.msrc_dss_tcc_us + DL1A_DSS_OVERHEAD);
  620   3              }
  621   2              else if (enables.msrc)
  622   2              {
  623   3                  used_budget_us += (timeouts.msrc_dss_tcc_us + DL1A_MSRC_OVERHEAD);
  624   3              }
  625   2      
  626   2              if (enables.pre_range)
  627   2              {
  628   3                  used_budget_us += (timeouts.pre_range_us + DL1A_PRERANGE_OVERHEAD);
  629   3              }
  630   2      
  631   2              if (enables.final_range)
  632   2              {
  633   3                  // è¯·æ³¨æ„ æœ€ç»ˆèŒƒå›´è¶…æ—¶ç”±è®¡æ—¶é¢„ç®—å’Œåºåˆ—ä¸­æ‰€æœ‰å…¶ä»–è¶…æ—¶çš„æ€»å’Œå†³å®š
  634   3                  // å¦‚æœæ²¡æœ‰ç©ºé—´ç”¨äºæœ€ç»ˆèŒƒå›´è¶…æ—¶ åˆ™å°†è®¾ç½®é”™è¯¯
  635   3                  // å¦åˆ™ å‰©ä½™æ—¶é—´å°†åº”ç”¨äºæœ€ç»ˆèŒƒå›´
  636   3                  used_budget_us += DL1A_FINALlRANGE_OVERHEAD;
  637   3                  if (used_budget_us > budget_us)
  638   3                  {
  639   4                      // è¯·æ±‚çš„è¶…æ—¶å¤ªå¤§
  640   4                      return_state = 1;
  641   4                      break;
  642   4                  }
  643   3      
  644   3                  // å¯¹äºæœ€ç»ˆè¶…æ—¶èŒƒå›´ å¿…é¡»æ·»åŠ é¢„é‡ç¨‹èŒƒå›´è¶…æ—¶
  645   3                  // ä¸ºæ­¤ æœ€ç»ˆè¶…æ—¶å’Œé¢„é‡ç¨‹è¶…æ—¶å¿…é¡»ä»¥å®å‘¨æœŸ MClks è¡¨ç¤º
  646   3                  // å› ä¸ºå®ƒä»¬å…·æœ‰ä¸åŒçš„ VCSEL å‘¨æœŸ
  647   3                  final_range_timeout_us = budget_us - used_budget_us;
  648   3                  final_range_timeout_mclks =
  649   3                      dl1a_timeout_microseconds_to_mclks(final_range_timeout_us,
  650   3                                                         (uint8)timeouts.final_range_vcsel_period_pclks);
  651   3      
  652   3                  if (enables.pre_range)
  653   3                  {
  654   4                      final_range_timeout_mclks += timeouts.pre_range_mclks;
  655   4                  }
  656   3      
  657   3                  dat = dl1a_encode_timeout(final_range_timeout_mclks);
  658   3                  data_buffer[0] = DL1A_FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI;
  659   3                  data_buffer[1] = ((dat >> 8) & 0xFF);
  660   3                  data_buffer[2] = (dat & 0xFF);
  661   3                  dl1a_write_array(data_buffer, 3);
  662   3              }
  663   2          } while (0);
  664   1          return return_state;
  665   1      }
  666          
  667          //-------------------------------------------------------------------------------------------------------
             -------------
  668          // å‡½æ•°ç®€ä»‹     è·å–æµ‹é‡å®šæ—¶é¢„ç®— (ä»¥å¾®ç§’ä¸ºå•ä½)
  669          // å‚æ•°è¯´æ˜     void
  670          // è¿”å›å‚æ•°     uint32          å·²è®¾å®šçš„æµ‹é‡å…è®¸çš„æ—¶é—´
  671          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_measurement_timing_budget();
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 12  

  672          // å¤‡æ³¨ä¿¡æ¯
  673          //-------------------------------------------------------------------------------------------------------
             -------------
  674          static uint32 dl1a_get_measurement_timing_budget(void)
  675          {
  676   1          dl1a_sequence_enables_step_struct enables;
  677   1          dl1a_sequence_timeout_step_struct timeouts;
  678   1      
  679   1          // å¼€å§‹å’Œç»“æŸå¼€é”€æ—¶é—´å§‹ç»ˆå­˜åœ¨
  680   1          uint32 budget_us = DL1A_GET_START_OVERHEAD + DL1A_END_OVERHEAD;
  681   1      
  682   1          dl1a_get_sequence_step_enables(&enables);
  683   1          dl1a_get_sequence_step_timeouts(&enables, &timeouts);
  684   1      
  685   1          if (enables.tcc)
  686   1          {
  687   2              budget_us += (timeouts.msrc_dss_tcc_us + DL1A_TCC_OVERHEAD);
  688   2          }
  689   1      
  690   1          if (enables.dss)
  691   1          {
  692   2              budget_us += 2 * (timeouts.msrc_dss_tcc_us + DL1A_DSS_OVERHEAD);
  693   2          }
  694   1          else if (enables.msrc)
  695   1          {
  696   2              budget_us += (timeouts.msrc_dss_tcc_us + DL1A_MSRC_OVERHEAD);
  697   2          }
  698   1      
  699   1          if (enables.pre_range)
  700   1          {
  701   2              budget_us += (timeouts.pre_range_us + DL1A_PRERANGE_OVERHEAD);
  702   2          }
  703   1      
  704   1          if (enables.final_range)
  705   1          {
  706   2              budget_us += (timeouts.final_range_us + DL1A_FINALlRANGE_OVERHEAD);
  707   2          }
  708   1      
  709   1          return budget_us;
  710   1      }
  711          
  712          //-------------------------------------------------------------------------------------------------------
             -------------
  713          // å‡½æ•°ç®€ä»‹     è®¾ç½®è¿”å›ä¿¡å·é€Ÿç‡é™åˆ¶ è¯¥å€¼å•ä½ä¸º MCPS (ç™¾ä¸‡æ¬¡æ¯ç§’)
  714          // å‚æ•°è¯´æ˜     limit_mcps      è®¾ç½®çš„æœ€å°é€Ÿç‡
  715          // è¿”å›å‚æ•°     void
  716          // ä½¿ç”¨ç¤ºä¾‹     dl1a_set_signal_rate_limit(0.25);
  717          // å¤‡æ³¨ä¿¡æ¯     è¿™ä¸ªé€Ÿç‡è¡¨ç¤ºä»ç›®æ ‡åå°„å¹¶è¢«è®¾å¤‡æ£€æµ‹åˆ°çš„ä¿¡å·çš„æŒ¯å¹…
  718          //              è®¾ç½®æ­¤é™åˆ¶å¯ä»¥ç¡®å®šä¼ æ„Ÿå™¨æŠ¥å‘Šæœ‰æ•ˆè¯»æ•°æ‰€éœ€çš„æœ€å°æµ‹é‡å€¼
  719          //              è®¾ç½®ä¸€ä¸ªè¾ƒä½çš„é™åˆ¶å¯ä»¥å¢åŠ ä¼ æ„Ÿå™¨çš„æµ‹é‡èŒƒå›´
  720          //              ä½†ä¼¼ä¹ä¹Ÿå¢åŠ äº† <ç”±äºæ¥è‡ªç›®æ ‡ä»¥å¤–çš„ç‰©ä½“çš„ä¸éœ€è¦çš„åå°„å¯¼è‡´> å¾—å
             -ˆ°ä¸å‡†ç¡®è¯»æ•°çš„å¯èƒ½æ€§
  721          //              é»˜è®¤ä¸º 0.25 MCPS å¯é¢„è®¾èŒƒå›´ä¸º 0 - 511.99
  722          //-------------------------------------------------------------------------------------------------------
             -------------
  723          static void dl1a_set_signal_rate_limit(float limit_mcps)
  724          {
  725   1          uint8 data_buffer[3];
  726   1          uint16 limit_mcps_16bit = (limit_mcps * (1 << 7));
  727   1          // zf_assert(limit_mcps >= 0 || limit_mcps <= 511.99);
  728   1      
  729   1          data_buffer[0] = DL1A_FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT;
  730   1          data_buffer[1] = ((limit_mcps_16bit >> 8) & 0xFF);
  731   1          data_buffer[2] = (limit_mcps_16bit & 0xFF);
  732   1      
  733   1          dl1a_write_array(data_buffer, 3);
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 13  

  734   1      }
  735          
  736          //-------------------------------------------------------------------------------------------------------
             -------------
  737          // å‡½æ•°ç®€ä»‹     è¿”å›ä»¥æ¯«ç±³ä¸ºå•ä½çš„èŒƒå›´è¯»æ•°
  738          // å‚æ•°è¯´æ˜     void
  739          // è¿”å›å‚æ•°     uint8           0-æ•°æ®æ— æ•ˆ 1-æ•°æ®æœ‰æ•ˆ
  740          // ä½¿ç”¨ç¤ºä¾‹     dl1a_get_distance();
  741          // å¤‡æ³¨ä¿¡æ¯     åœ¨å¼€å§‹å•æ¬¡å°„ç¨‹æµ‹é‡åä¹Ÿè°ƒç”¨æ­¤å‡½æ•°
  742          //-------------------------------------------------------------------------------------------------------
             -------------
  743          void dl1a_get_distance(void)
  744          {
  745   1          uint8 reg_databuffer[3];
  746   1      
  747   1          dl1a_read_registers_1(DL1A_RESULT_INTERRUPT_STATUS, reg_databuffer, 1);
  748   1          if ((reg_databuffer[0] & 0x07) == 0)
  749   1          {
  750   2              dl1a_finsh_flag = 0;
  751   2          }
  752   1          else
  753   1          {
  754   2              // å‡è®¾çº¿æ€§åº¦æ ¡æ­£å¢ç›Šä¸ºé»˜è®¤å€¼ 1000 ä¸”æœªå¯ç”¨åˆ†æ•°èŒƒå›´
  755   2              dl1a_read_registers_1(DL1A_RESULT_RANGE_STATUS + 10, reg_databuffer, 2);
  756   2              dl1a_distance_mm = ((uint16)reg_databuffer[0] << 8);
  757   2              dl1a_distance_mm |= reg_databuffer[1];
  758   2      
  759   2              dl1a_write_register(DL1A_SYSTEM_INTERRUPT_CLEAR, 0x01);
  760   2              dl1a_finsh_flag = 1;
  761   2          }
  762   1      }
  763          
  764          //-------------------------------------------------------------------------------------------------------
             -------------
  765          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– DL1A
  766          // å‚æ•°è¯´æ˜     void
  767          // è¿”å›å‚æ•°     uint8           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  768          // ä½¿ç”¨ç¤ºä¾‹     dl1a_init();
  769          // å¤‡æ³¨ä¿¡æ¯
  770          //-------------------------------------------------------------------------------------------------------
             -------------
  771          uint8 dl1a_init(void)
  772          {
  773   1          uint32 measurement_timing_budget_us = 0;
  774   1          uint8 stop_variable = 0;
  775   1          uint8 return_state = 0;
  776   1          uint8 reg_data_buffer = 0;
  777   1          uint8 ref_spad_map[6];
  778   1          uint8 data_buffer[7];
  779   1          uint8 i = 0;
  780   1      
  781   1          memset(ref_spad_map, 0, 6);
  782   1          memset(data_buffer, 0, 7);
  783   1          do
  784   1          {
  785   2              delay_ms(100);
  786   2              DL1A_XSHUT_PIN = 0;
  787   2              delay_ms(50);
  788   2              DL1A_XSHUT_PIN = 1;
  789   2              delay_ms(100);
  790   2      
  791   2              // -------------------------------- DL1A å¯åŠ¨åˆå§‹åŒ– --------------------------------
  792   2              reg_data_buffer = dl1a_read_register(DL1A_IO_VOLTAGE_CONFIG);        // ä¼ æ„Ÿå™¨é»˜è®¤ IO ä¸º 1.
             -8V æ¨¡å¼
  793   2              dl1a_write_register(DL1A_IO_VOLTAGE_CONFIG, reg_data_buffer | 0x01); // é…ç½® IO ä¸º 2.8V æ¨¡å¼
  794   2      
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 14  

  795   2              dl1a_write_register(0x88, 0x00); // è®¾ç½®ä¸ºæ ‡å‡† IIC æ¨¡å¼
  796   2      
  797   2              dl1a_write_register(0x80, 0x01);
  798   2              dl1a_write_register(0xFF, 0x01);
  799   2              dl1a_write_register(0x00, 0x00);
  800   2      
  801   2              dl1a_read_registers(0x91, &stop_variable, 1);
  802   2      
  803   2              dl1a_write_register(0x00, 0x01);
  804   2              dl1a_write_register(0xFF, 0x00);
  805   2              dl1a_write_register(0x80, 0x00);
  806   2      
  807   2              // ç¦ç”¨ SIGNAL_RATE_MSRC(bit1) å’Œ SIGNAL_RATE_PRE_RANGE(bit4) é™åˆ¶æ£€æŸ¥
  808   2              reg_data_buffer = dl1a_read_register(DL1A_MSRC_CONFIG);
  809   2              dl1a_write_register(DL1A_MSRC_CONFIG, reg_data_buffer | 0x12);
  810   2      
  811   2              dl1a_set_signal_rate_limit(DL1A_DEFAULT_RATE_LIMIT); // è®¾ç½®ä¿¡å·é€Ÿç‡é™åˆ¶
  812   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0xFF);
  813   2              // -------------------------------- DL1A å¯åŠ¨åˆå§‹åŒ– --------------------------------
  814   2      
  815   2              // -------------------------------- DL1A é…ç½®åˆå§‹åŒ– --------------------------------
  816   2              if (dl1a_get_spad_info(&data_buffer[0], &data_buffer[1]))
  817   2              {
  818   3                  return_state = 1;
  819   3                  // å¦‚æœç¨‹åºåœ¨è¾“å‡ºäº†æ–­è¨€ä¿¡æ¯ å¹¶ä¸”æç¤ºå‡ºé”™ä½ç½®åœ¨è¿™é‡Œ
  820   3                  // é‚£ä¹ˆå°±æ˜¯ dl1a è‡ªæ£€å‡ºé”™å¹¶è¶…æ—¶é€€å‡ºäº†
  821   3                  // æ£€æŸ¥ä¸€ä¸‹æ¥çº¿æœ‰æ²¡æœ‰é—®é¢˜ å¦‚æœæ²¡é—®é¢˜å¯èƒ½å°±æ˜¯åäº†
  822   3      
  823   3                  printf("dl1a init error.\r\n");
  824   3                  break;
  825   3              }
  826   2      
  827   2              // ä» GLOBAL_CONFIG_SPAD_ENABLES_REF_[0-6] è·å– SPAD map (RefGoodSpadMap) æ•°æ®
  828   2              dl1a_read_registers(DL1A_GLOBAL_CONFIG_SPAD_ENABLES_REF_0, ref_spad_map, 6);
  829   2      
  830   2              dl1a_write_register(0xFF, 0x01);
  831   2              dl1a_write_register(DL1A_DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
  832   2              dl1a_write_register(DL1A_DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
  833   2              dl1a_write_register(0xFF, 0x00);
  834   2              dl1a_write_register(DL1A_GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);
  835   2      
  836   2              data_buffer[2] = data_buffer[1] ? 12 : 0; // 12 is the first aperture spad
  837   2              for (i = 0; i < 48; i++)
  838   2              {
  839   3                  if (i < data_buffer[2] || data_buffer[3] == data_buffer[0])
  840   3                  {
  841   4                      // æ­¤ä½ä½äºåº”å¯ç”¨çš„ç¬¬ä¸€ä¸ªä½
  842   4                      // æˆ–è€… (eference_spad_count) ä½å·²å¯ç”¨
  843   4                      // å› æ­¤æ­¤ä½ä¸ºé›¶
  844   4                      ref_spad_map[i / 8] &= ~(1 << (i % 8));
  845   4                  }
  846   3                  else if ((ref_spad_map[i / 8] >> (i % 8)) & 0x1)
  847   3                  {
  848   4                      data_buffer[3]++;
  849   4                  }
  850   3              }
  851   2      
  852   2              data_buffer[0] = DL1A_GLOBAL_CONFIG_SPAD_ENABLES_REF_0;
  853   2              for (i = 1; i < 7; i++)
  854   2              {
  855   3                  data_buffer[1] = ref_spad_map[i - 1];
  856   3              }
  857   2              dl1a_write_array(data_buffer, 7);
  858   2      
  859   2              // é»˜è®¤è½¬æ¢è®¾ç½® version 02/11/2015_v36
  860   2              dl1a_write_register(0xFF, 0x01);
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 15  

  861   2              dl1a_write_register(0x00, 0x00);
  862   2              dl1a_write_register(0xFF, 0x00);
  863   2              dl1a_write_register(0x09, 0x00);
  864   2              dl1a_write_register(0x10, 0x00);
  865   2              dl1a_write_register(0x11, 0x00);
  866   2              dl1a_write_register(0x24, 0x01);
  867   2              dl1a_write_register(0x25, 0xFF);
  868   2              dl1a_write_register(0x75, 0x00);
  869   2              dl1a_write_register(0xFF, 0x01);
  870   2              dl1a_write_register(0x4E, 0x2C);
  871   2              dl1a_write_register(0x48, 0x00);
  872   2              dl1a_write_register(0x30, 0x20);
  873   2              dl1a_write_register(0xFF, 0x00);
  874   2              dl1a_write_register(0x30, 0x09);
  875   2              dl1a_write_register(0x54, 0x00);
  876   2              dl1a_write_register(0x31, 0x04);
  877   2              dl1a_write_register(0x32, 0x03);
  878   2              dl1a_write_register(0x40, 0x83);
  879   2              dl1a_write_register(0x46, 0x25);
  880   2              dl1a_write_register(0x60, 0x00);
  881   2              dl1a_write_register(0x27, 0x00);
  882   2              dl1a_write_register(0x50, 0x06);
  883   2              dl1a_write_register(0x51, 0x00);
  884   2              dl1a_write_register(0x52, 0x96);
  885   2              dl1a_write_register(0x56, 0x08);
  886   2              dl1a_write_register(0x57, 0x30);
  887   2              dl1a_write_register(0x61, 0x00);
  888   2              dl1a_write_register(0x62, 0x00);
  889   2              dl1a_write_register(0x64, 0x00);
  890   2              dl1a_write_register(0x65, 0x00);
  891   2              dl1a_write_register(0x66, 0xA0);
  892   2              dl1a_write_register(0xFF, 0x01);
  893   2              dl1a_write_register(0x22, 0x32);
  894   2              dl1a_write_register(0x47, 0x14);
  895   2              dl1a_write_register(0x49, 0xFF);
  896   2              dl1a_write_register(0x4A, 0x00);
  897   2              dl1a_write_register(0xFF, 0x00);
  898   2              dl1a_write_register(0x7A, 0x0A);
  899   2              dl1a_write_register(0x7B, 0x00);
  900   2              dl1a_write_register(0x78, 0x21);
  901   2              dl1a_write_register(0xFF, 0x01);
  902   2              dl1a_write_register(0x23, 0x34);
  903   2              dl1a_write_register(0x42, 0x00);
  904   2              dl1a_write_register(0x44, 0xFF);
  905   2              dl1a_write_register(0x45, 0x26);
  906   2              dl1a_write_register(0x46, 0x05);
  907   2              dl1a_write_register(0x40, 0x40);
  908   2              dl1a_write_register(0x0E, 0x06);
  909   2              dl1a_write_register(0x20, 0x1A);
  910   2              dl1a_write_register(0x43, 0x40);
  911   2              dl1a_write_register(0xFF, 0x00);
  912   2              dl1a_write_register(0x34, 0x03);
  913   2              dl1a_write_register(0x35, 0x44);
  914   2              dl1a_write_register(0xFF, 0x01);
  915   2              dl1a_write_register(0x31, 0x04);
  916   2              dl1a_write_register(0x4B, 0x09);
  917   2              dl1a_write_register(0x4C, 0x05);
  918   2              dl1a_write_register(0x4D, 0x04);
  919   2              dl1a_write_register(0xFF, 0x00);
  920   2              dl1a_write_register(0x44, 0x00);
  921   2              dl1a_write_register(0x45, 0x20);
  922   2              dl1a_write_register(0x47, 0x08);
  923   2              dl1a_write_register(0x48, 0x28);
  924   2              dl1a_write_register(0x67, 0x00);
  925   2              dl1a_write_register(0x70, 0x04);
  926   2              dl1a_write_register(0x71, 0x01);
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 16  

  927   2              dl1a_write_register(0x72, 0xFE);
  928   2              dl1a_write_register(0x76, 0x00);
  929   2              dl1a_write_register(0x77, 0x00);
  930   2              dl1a_write_register(0xFF, 0x01);
  931   2              dl1a_write_register(0x0D, 0x01);
  932   2              dl1a_write_register(0xFF, 0x00);
  933   2              dl1a_write_register(0x80, 0x01);
  934   2              dl1a_write_register(0x01, 0xF8);
  935   2              dl1a_write_register(0xFF, 0x01);
  936   2              dl1a_write_register(0x8E, 0x01);
  937   2              dl1a_write_register(0x00, 0x01);
  938   2              dl1a_write_register(0xFF, 0x00);
  939   2              dl1a_write_register(0x80, 0x00);
  940   2      
  941   2              // å°†ä¸­æ–­é…ç½®è®¾ç½®ä¸ºæ–°æ ·å“å°±ç»ª
  942   2              dl1a_write_register(DL1A_SYSTEM_INTERRUPT_GPIO_CONFIG, 0x04);
  943   2              reg_data_buffer = dl1a_read_register(DL1A_GPIO_HV_MUX_ACTIVE_HIGH);
  944   2              dl1a_write_register(DL1A_GPIO_HV_MUX_ACTIVE_HIGH, reg_data_buffer & ~0x10);
  945   2              dl1a_write_register(DL1A_SYSTEM_INTERRUPT_CLEAR, 0x01);
  946   2      
  947   2              measurement_timing_budget_us = dl1a_get_measurement_timing_budget();
  948   2      
  949   2              // é»˜è®¤æƒ…å†µä¸‹ç¦ç”¨ MSRC å’Œ TCC
  950   2              // MSRC = Minimum Signal Rate Check
  951   2              // TCC = Target CentreCheck
  952   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0xE8);
  953   2              dl1a_set_measurement_timing_budget(measurement_timing_budget_us); // é‡æ–°è®¡ç®—æ—¶åºé¢„ç®—
  954   2              // -------------------------------- DL1A é…ç½®åˆå§‹åŒ– --------------------------------
  955   2      
  956   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0x01);
  957   2              if (dl1a_perform_single_ref_calibration(0x40))
  958   2              {
  959   3                  return_state = 1;
  960   3                  break;
  961   3              }
  962   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0x02);
  963   2              if (dl1a_perform_single_ref_calibration(0x00))
  964   2              {
  965   3                  return_state = 1;
  966   3                  break;
  967   3              }
  968   2              dl1a_write_register(DL1A_SYSTEM_SEQUENCE_CONFIG, 0xE8); // æ¢å¤ä»¥å‰çš„åºåˆ—é…ç½®
  969   2      
  970   2              delay_ms(100);
  971   2      
  972   2              dl1a_write_register(0x80, 0x01);
  973   2              dl1a_write_register(0xFF, 0x01);
  974   2              dl1a_write_register(0x00, 0x00);
  975   2              dl1a_write_register(0x91, stop_variable);
  976   2              dl1a_write_register(0x00, 0x01);
  977   2              dl1a_write_register(0xFF, 0x00);
  978   2              dl1a_write_register(0x80, 0x00);
  979   2      
  980   2              dl1a_write_register(DL1A_SYSRANGE_START, 0x02);
  981   2          } while (0);
  982   1      
  983   1          return return_state;
  984   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4624     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
C251 COMPILER V5.60.0,  SEEKFREE_DL1A                                                      22/05/24  18:31:13  PAGE 17  

  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       222     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        19     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
