C251 COMPILER V5.60.0,  direction                                                          28/05/24  12:24:03  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE direction
OBJECT MODULE PLACED IN .\Out_File\direction.obj
COMPILER INVOKED BY: E:\Keil5C251\C251\BIN\C251.EXE ..\USER\Hardware\direction.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEED
                    -) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE
                    -;..\USER\inc;..\USER\src;..\USER\Hardware;..\USER\Hardware) DEBUG PRINT(.\Out_File\direction.lst) TABS(2) OBJECT(.\Out_F
                    -ile\direction.obj) 

stmt  level    source

    1          /*
    2           * @Description:
    3           * @Author: Yzhi
    4           * @Date: 2023-11-17 21:24:19
    5           * @LastEditTime: 2024-01-19 11:52:20
    6           * @LastEditors: Yzhi
    7           */
    8          #include "myconfig.h"
    9          
   10          #define out_max 20000
   11          #define Angle_MAX 3500
   12          
   13          
   14          
   15          float Nh_P = 120; // 0.5
   16          float Nh_D = 30; // 4.1
   17          float Wh_P = 1.25;
   18          float Wh_D = 2 ;
   19          float gyro_z3 = 0;
   20          
   21          float KP1 = 35;
   22          float KP2 = 0.2;
   23          float KP3 = 0; 
   24          float KD1 = 0;
   25          float KD2 = 0;
   26          float Feedforward_gain = 0;
   27          
   28          
   29          float Angle_Speed_P = 415;
   30          float Angle_Speed_I = 9.2;
   31          
   32          float Target_Vel_Z_pre = 0;
   33          int Speed_Ring_Flag = 0;
   34          
   35          Position_PID_InitTypedef Position;
   36          
   37          /**
   38           * @brief 外环
   39           *
   40           * @param chazhi 电感差值PD控制
   41           * @param dir_p  KP
   42           * @param dir_d  KD
   43           * @return int   外环返回值
   44           */
   45          
   46          float wh_Turn_Out(int16 chazhi, float dir_p, float dir_d)
   47          {
   48   1        float error;
   49   1        static float last_error = 0;
   50   1        float Output;
   51   1        float error_derivative;
   52   1      
   53   1        error = chazhi;
   54   1      
   55   1        error_derivative = error - last_error;
   56   1      
C251 COMPILER V5.60.0,  direction                                                          28/05/24  12:24:03  PAGE 2   

   57   1        Output = error * dir_p + error_derivative * dir_d;
   58   1      
   59   1        last_error = error;
   60   1      
   61   1        Target_Vel_Z_pre = Output;
   62   1      
   63   1        return Output;
   64   1      }
   65          
   66          /**
   67           * @brief 内环角速度PI控制
   68           *
   69           * @param err   外环输入值
   70           * @param dir_p
   71           * @param dir_i
   72           * @return int
   73           */
   74          int16 nh_Turn_Out(float err, float dir_p, float dir_d)
   75          {
   76   1        float error,KP,KD;
   77   1      
   78   1        static float last_error;
   79   1      
   80   1        float price_Differention;
   81   1      
   82   1        float price_Proportion;
   83   1      
   84   1        static float Pre1_Error[4];
   85   1      
   86   1        float Direct_Parameter;
   87   1      
   88   1      
   89   1        KP=dir_p ; // 不要调
   90   1      
   91   1        KD=dir_d; // 不要调
   92   1      
   93   1      
   94   1        error = err * 8.5 - imu660ra_gyro_z * 1.2; // 转向内环参数，一般不用改，改变后面的参
             -数，改变阻尼大小
   95   1        // 转向PD控制
   96   1        price_Proportion = dir_p * error;
   97   1      
   98   1        price_Differention = dir_d * (error - last_error);
   99   1      
  100   1        Direct_Parameter = price_Proportion + price_Differention; //(1+error*error*0.000000001f)
  101   1      
  102   1        last_error = error;
  103   1      
  104   1        Pre1_Error[3] = Pre1_Error[2];
  105   1      
  106   1        Pre1_Error[2] = Pre1_Error[1];
  107   1      
  108   1        Pre1_Error[1] = Pre1_Error[0];
  109   1      
  110   1        Pre1_Error[0] = Direct_Parameter;
  111   1      
  112   1        Direct_Parameter = Pre1_Error[0] * 0.8 + Pre1_Error[1] * 0.1 + Pre1_Error[2] * 0.06 + Pre1_Error[3] * 0
             -.04;
  113   1      
  114   1        return  (int16)(Direct_Parameter);
  115   1      }
  116          
  117          /**
  118           * @brief 方向环，串级PID给电机
  119           *
  120           * @return int
C251 COMPILER V5.60.0,  direction                                                          28/05/24  12:24:03  PAGE 3   

  121           */
  122          
  123          void Dir_PID_Init(void)
  124          {
  125   1        Position.kP1 = KP1;
  126   1        Position.kP2 = KP3;
  127   1        Position.kP3 = KP2;
  128   1        Position.kD  = KD1;
  129   1        Position.kD2 = KD2;
  130   1        Position.feedforward_gain = Feedforward_gain;
  131   1      }
  132          
  133          
  134          
  135          //K1 适合直道   K2适合弯中的姿态(内切)
  136          int16 DirControl(int error)
  137          {
  138   1        Position.err = error;
  139   1        Position.KP_Val = (int16)(Position.kP1 * Position.err + Position.kP2 * Position.err * Position.err * Po
             -sition.err);
  140   1        Position.kD_Val = (int16)(Position.kD*mpu6050_gyro_z);
  141   1        Position.kD2_Val = (int16)(Position.kD2 * (Position.err - Position.err_last));
  142   1        Position.err_last = Position.err;
  143   1        Position.feedforward_Val = Position.feedforward_gain * error;
  144   1        Position.Out = Position.KP_Val + Position.kD_Val + Position.feedforward_Val + Position.kD2_Val;
  145   1        return (int16)Position.Out;
  146   1      }
  147          
  148          
  149          
  150          // int DirControl(void)
  151          // {
  152          //   int error = 0;
  153          //   static int last_error;
  154          //   int out = 0;
  155          //   error = Inductance_Error;
  156          //   out = error * KP1 + error * asb(error) * KP2 + (error - last_error) * KD1 - imu660ra_gyro_z / 65.6 *
             - KD1;
  157          //   last_error = error;
  158          //   return out;
  159          // }
  160          
  161          /**
  162           * @brief 角度环
  163           *
  164           * @param target 目标角度
  165           * @param p
  166           * @param d
  167           * @return int
  168           */
  169          int Angle_Ring(double target, float p, float d)
  170          {
  171   1        float error;
  172   1        int Output, Angle_Speed;
  173   1        static float last_error, error2;
  174   1        gyro_z3 += Get_Gyro_Z;
  175   1        error = target - gyro_z3;
  176   1        error2 = error - last_error;
  177   1        last_error = error;
  178   1        Output = (int)(error * p + error2 * d);
  179   1        Output = limit(Output, 1000);
  180   1        Angle_Speed_Ring(Output, Angle_Speed_P, Angle_Speed_I);
  181   1        if (abs(error) <= 2) // 如何小于指定角度，表示角度ok
  182   1        {
  183   2          gyro_z3 = 0; // 角度积分清零
  184   2          last_error = 0;
C251 COMPILER V5.60.0,  direction                                                          28/05/24  12:24:03  PAGE 4   

  185   2          error2 = 0;
  186   2          return 1;
  187   2        }
  188   1        else
  189   1          return 0;
  190   1      }
*** WARNING C47 IN LINE 172 OF ..\USER\Hardware\direction.c: 'Angle_Speed': unreferenced local variable
  191          
  192          /**
  193           * @brief 角速度环
  194           *
  195           * @param err
  196           * @param dir_p
  197           * @param dir_i
  198           * @return int
  199           */
  200          int Angle_Speed_Ring(int err, float dir_p, float dir_i)
  201          {
  202   1        int error1 = 0;
  203   1        static float last_err = 0, nh_out = 0, P_out = 0, I_out = 0, out = 0;
  204   1        error1 = err - Get_Gyro_Z*10;
  205   1        P_out = dir_p * (error1 - last_err);
  206   1        I_out = dir_i * error1;
  207   1        if (I_out > 2000)
  208   1          I_out = 2000;
  209   1        if (I_out < -2000)
  210   1          I_out = -2000;
  211   1        out = P_out + I_out;
  212   1        nh_out += out;
  213   1        last_err = error1;
  214   1        nh_out = limit(nh_out, 9500);
  215   1        Motor_PWM(-nh_out, nh_out);
  216   1        return nh_out;
  217   1      }
  218          
  219          int DirControl_2(int16 chazhi, float dir_p, float dir_d, float dir_d2)
  220          {
*** WARNING C57 IN LINE 220 OF ..\USER\Hardware\direction.c: parameter 1: different from declaration
  221   1        float error;
  222   1        static float last_error = 0;
  223   1        float Output;
  224   1        float error_derivative;
  225   1      
  226   1        error = chazhi;
  227   1      
  228   1        error_derivative = error - last_error;
  229   1      
  230   1        Output = error * dir_p + error_derivative * dir_d + Get_Gyro_Z*10* dir_d2;
  231   1      
  232   1        last_error = error;
  233   1      
  234   1        Output = limit(Output, out_max);
  235   1        return (int)Output;
  236   1      }
  237          
  238          /**
  239           * @brief 控制车行驶的距离
  240           *
  241           * @param L_Distanc
  242           * @param R_Distance
  243           */
  244          int Car_Distance(int Distance)
  245          {
  246   1        static int bmq_jifen, flag = 1;
  247   1        bmq_jifen += (L_Pulse + R_Pulse) * 0.5;
  248   1        if (bmq_jifen <= Distance)
C251 COMPILER V5.60.0,  direction                                                          28/05/24  12:24:03  PAGE 5   

  249   1        {
  250   2          // LSpeed_pid_Out(20, L_Pulse);
  251   2          // RSpeed_pid_Out(20, R_Pulse);
  252   2          //Motor_PWM(LSpeed_pid_Out(20, L_Pulse), RSpeed_pid_Out(20, R_Pulse));
  253   2        }
  254   1        else if (bmq_jifen > Distance)
  255   1        {
  256   2          if (Angle_Ring(90, 25, 1) == 1)
  257   2          {
  258   3            bmq_jifen = 0;
  259   3            L_Pulse = 0;
  260   3            R_Pulse = 0;
  261   3            gyro_z3 = 0;
  262   3          }
  263   2          return 1;
  264   2        }
  265   1      }
*** WARNING C180 IN LINE 264 OF ..\USER\Hardware\direction.c: 'Car_Distance': not every path returns a value
*** WARNING C180 IN LINE 264 OF ..\USER\Hardware\direction.c: 'Car_Distance': not every path returns a value


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1334     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       304     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       180     ------
End of Module Information.


C251 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
