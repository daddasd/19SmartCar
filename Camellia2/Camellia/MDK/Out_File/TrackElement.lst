C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE TrackElement
OBJECT MODULE PLACED IN .\Out_File\TrackElement.obj
COMPILER INVOKED BY: F:\Keil_c251\C251\BIN\C251.EXE ..\USER\Hardware\TrackElement.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SP
                    -EED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\C
                    -ODE;..\USER\inc;..\USER\src;..\USER\Hardware;..\USER\Hardware) DEBUG PRINT(.\Out_File\TrackElement.lst) TABS(2) OBJECT(.
                    -\Out_File\TrackElement.obj) 

stmt  level    source

    1          /*
    2           * @Description:
    3           * @Author: Yzhi
    4           * @Date: 2024-01-10 09:24:18
    5           * @LastEditTime: 2024-01-10 09:32:32
    6           * @LastEditors: Yzhi
    7           */
    8          #include "myconfig.h"
    9          
   10          int Element_Order[4] = {0};
   11          
   12          int shizi_flag = 0;
   13          int ring_flag = -1;
   14          long bmq_jifen = 0;
   15          double angle_jifen = 0;
   16          int Track_flag = 0; // 正常循迹
   17          int set_speed = 0;  // 在赛道上不断更改速度
   18          
   19          int Elements_List[8];
   20          int Elements_Num = 1;
   21          
   22          //*******************避障*****************//
   23          uint8 Obstacle_State = 0; // 避障状态
   24          int Distance_Jifen = 0;
   25          int Obstacle_Distance1 = 1800; // 第一次直行的距离
   26          int Obstacle_Distance2 = 2548; // 第二次直行的距离
   27          
   28          int Obstacle_Flag = 0;
   29          
   30          //*******************环岛*****************//
   31          uint8 Ring_state = 0;
   32          
   33          int Yuan_Speed = 50;
   34          
   35          int Yuan_TrackSpeed = 0; // 环内循迹速度
   36          
   37          int Yu_Speed = 1200;   // 预进环岛速度
   38          int Yu_Distance = 3600;  // 预进环岛距离
   39          int Yu_Speed_Diff = 800; // 打角的速度差异
   40          
   41          int Chu_Speed = 1000;   // 预出环岛速度
   42          int Chu_Distance = 2800;  // 预出环岛距离
   43          int Chu_Speed_Diff = 800; // 打角的速度差异
   44          
   45          int In_Huan_Flag = 0;
   46          
   47          #define Judgment_loop 1;
   48          
   49          int End_Chu_Distance = 2000; // 出环岛距离
   50          
   51          int Huan_Dao_Flag = 0;
   52          
   53          int ANGLE_FLAG = 0;    // 角度积分标志
   54          double Angle4 = 0;     // 角度积分
   55          int DISTANCE_FLAG = 0; // 距离积分标志
   56          long Distance = 0;     // 距离积分
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 2   

   57          
   58          int RAngle_Flag = 0; // 90度标志位
   59          /******************坡道*****************/
   60          
   61          int Dowm_Ramp_Flag = 0;
   62          
   63          /*外环与电机pid与速度改变的参数*/
   64          
   65          double Sub_wh_p = 20;
   66          double Sub_wh_d = 10;
   67          double Sub_motor_p = 0;
   68          double Sub_motor_i = 0;
   69          int Sub_speed = -10;
   70          
   71          /*不同元素速度控制*/
   72          int Speed_Plan1 = 0;
   73          
   74          int Err_speed = 0;
   75          
   76          /**
   77           * @brief 向右避障
   78           *
   79           */
   80          // void RObstacle(void)
   81          // {
   82          //  int dir_out = 0, pwm = 0, diff_pwm, dir = 0;
   83          //  static int groy = 0, time = 0;
   84          
   85          //  switch (Obstacle_State)
   86          //  {
   87          //  case NO_LObstacle:
   88          //    if (dl1a_distance_mm < 1650)
   89          //    {
   90          //      Obstacle_State = Find_LObstacle;
   91          //      time = 0;
   92          //      gyro_z3 = 0;
   93          //      Buzzer_ON;
   94          //      Obstacle_Flag = 1; // 关闭正常循迹
   95          //    }
   96          //    break;
   97          //  case Find_LObstacle: // 拐角
   98          //    time++;
   99          //    pwm = Angle_Ring(60, gyro_z3);
  100          //    Motor_PWM(pwm, -pwm);
  101          //    if (time > 200)
  102          //    {
  103          //      time = 0;
  104          //      gyro_z3 = 0;
  105          //      Obstacle_State = LObstacle_straight;
  106          //    }
  107          //    break;
  108          //  case LObstacle_straight: // 直行
  109          //    if (Distance_Jifen < Obstacle_Distance1)
  110          //    {
  111          //      Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  112          //      diff_pwm = Angle_Ring(0, gyro_z3) * 0.6;
  113          //      pwm = Speed_pid_Out(60, Sum_Pulse);
  114          //      Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  115          //    }
  116          //    else
  117          //    {
  118          //      Distance_Jifen = 0;
  119          //      time = 0;
  120          //      gyro_z3 = 0;
  121          //      speed = 0;
  122          //      Obstacle_State = LObstacle_Angle1;
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 3   

  123          //    }
  124          //    break;
  125          //  case LObstacle_Angle1: // 拐角
  126          //    time++;
  127          //    pwm = Angle_Ring(-85, gyro_z3);
  128          //    Motor_PWM(pwm, -pwm);
  129          //    if (time > 200)
  130          //    {
  131          //      time = 0;
  132          //      gyro_z3 = 0;
  133          //      Distance_Jifen = 0;
  134          //      Obstacle_State = LObstacle_straight1;
  135          //    }
  136          //    break;
  137          //  case LObstacle_straight1: // 直行
  138          //    if (Distance_Jifen < Obstacle_Distance2)
  139          //    {
  140          //      Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  141          //      diff_pwm = Angle_Ring(0, gyro_z3) * 0.6;
  142          //      pwm = Speed_pid_Out(60, Sum_Pulse);
  143          //      Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  144          //    }
  145          //    else
  146          //    {
  147          //      Distance_Jifen = 0;
  148          //      time = 0;
  149          //      Obstacle_State = LObstacle_Over;
  150          //    }
  151          //    break;
  152          //  case LObstacle_Over:
  153          //    Obstacle_Flag = 0;
  154          //    Inductance_Error = 0;
  155          //    Obstacle_State = NO_LObstacle; // 防止误判       // 打开正常循迹
  156          //    Elements_Num++;          // 元素表++
  157          //    speed = 45;
  158          //    Buzzer_OFF;
  159          //    break;
  160          //  }
  161          // }
  162          
  163          void RObstacle(void)
  164          {
  165   1        int dir_out = 0, pwm = 0, diff_pwm, dir = 0;
  166   1        static int groy = 0, time = 0;
  167   1      
  168   1        switch (Obstacle_State)
  169   1        {
  170   2        case NO_LObstacle:
  171   2          if (dl1a_distance_mm < 1750)
  172   2          {
  173   3            Obstacle_State = Find_LObstacle;
  174   3            time = 0;
  175   3            gyro_z3 = 0;
  176   3            Buzzer_ON;
  177   3            Obstacle_Flag = 1; // 关闭正常循迹
  178   3          }
  179   2          break;
  180   2        case Find_LObstacle: // 拐角
  181   2          time++;
  182   2          pwm = Angle_Ring(60, gyro_z3);
  183   2          Motor_PWM(pwm, -pwm);
  184   2          if (time > 200)
  185   2          {
  186   3            time = 0;
  187   3            gyro_z3 = 0;
  188   3            Obstacle_State = LObstacle_straight;
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 4   

  189   3          }
  190   2          break;
  191   2        case LObstacle_straight: // 直行
  192   2          if (Distance_Jifen < Obstacle_Distance1)
  193   2          {
  194   3            Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  195   3            diff_pwm = Angle_Ring(0, gyro_z3) * 0.6;
  196   3            pwm = Speed_pid_Out(60, Sum_Pulse);
  197   3            Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  198   3          }
  199   2          else
  200   2          {
  201   3            Distance_Jifen = 0;
  202   3            time = 0;
  203   3            gyro_z3 = 0;
  204   3            speed = 0;
  205   3            Obstacle_State = LObstacle_Angle1;
  206   3          }
  207   2          break;
  208   2        case LObstacle_Angle1: // 拐角
  209   2          time++;
  210   2          pwm = Angle_Ring(-75, gyro_z3);
  211   2          Motor_PWM(pwm, -pwm);
  212   2          if (time > 200)
  213   2          {
  214   3            time = 0;
  215   3            gyro_z3 = 0;
  216   3            Distance_Jifen = 0;
  217   3            Obstacle_State = LObstacle_straight1;
  218   3          }
  219   2          break;
  220   2        case LObstacle_straight1: // 直行
  221   2          if (Distance_Jifen < Obstacle_Distance2)
  222   2          {
  223   3            Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  224   3            diff_pwm = Angle_Ring(0, gyro_z3) * 0.6;
  225   3            pwm = Speed_pid_Out(60, Sum_Pulse);
  226   3            Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  227   3          }
  228   2          else
  229   2          {
  230   3            Distance_Jifen = 0;
  231   3            time = 0;
  232   3            Obstacle_State = LObstacle_Over;
  233   3          }
  234   2          break;
  235   2        case LObstacle_Over:
  236   2          Obstacle_Flag = 0;
  237   2          Inductance_Error = 0;
  238   2          Obstacle_State = NO_LObstacle; // 防止误判       // 打开正常循迹
  239   2          Elements_Num++;          // 元素表++
  240   2          speed = 75;
  241   2          Buzzer_OFF;
  242   2          break;
  243   2        }
  244   1      }
  245          
  246          /**
  247           * @brief 向左避障
  248           *
  249           */
  250          void LObstacle(void)
  251          {
  252   1        int dir_out = 0, pwm = 0, diff_pwm, dir = 0;
  253   1        static int groy = 0, time = 0;
  254   1      
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 5   

  255   1        switch (Obstacle_State)
  256   1        {
  257   2        case NO_LObstacle:
  258   2          if (dl1a_distance_mm < 1750)
  259   2          {
  260   3            Obstacle_State = Find_LObstacle;
  261   3            time = 0;
  262   3            gyro_z3 = 0;
  263   3            Buzzer_ON;
  264   3            Obstacle_Flag = 1; // 关闭正常循迹
  265   3          }
  266   2          break;
  267   2        case Find_LObstacle: // 拐角
  268   2          time++;
  269   2          pwm = Angle_Ring(-60, gyro_z3);
  270   2          Motor_PWM(pwm, -pwm);
  271   2          if (time > 200)
  272   2          {
  273   3            time = 0;
  274   3            gyro_z3 = 0;
  275   3            Obstacle_State = LObstacle_straight;
  276   3          }
  277   2          break;
  278   2        case LObstacle_straight: // 直行
  279   2          if (Distance_Jifen < Obstacle_Distance1)
  280   2          {
  281   3            Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  282   3            diff_pwm = Angle_Ring(0, gyro_z3) * 0.6;
  283   3            pwm = Speed_pid_Out(60, Sum_Pulse);
  284   3            Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  285   3          }
  286   2          else
  287   2          {
  288   3            Distance_Jifen = 0;
  289   3            time = 0;
  290   3            gyro_z3 = 0;
  291   3            speed = 0;
  292   3            Obstacle_State = LObstacle_Angle1;
  293   3          }
  294   2          break;
  295   2        case LObstacle_Angle1: // 拐角
  296   2          time++;
  297   2          pwm = Angle_Ring(75, gyro_z3);
  298   2          Motor_PWM(pwm, -pwm);
  299   2          if (time > 200)
  300   2          {
  301   3            time = 0;
  302   3            gyro_z3 = 0;
  303   3            Distance_Jifen = 0;
  304   3            Obstacle_State = LObstacle_straight1;
  305   3          }
  306   2          break;
  307   2        case LObstacle_straight1: // 直行
  308   2          if (Distance_Jifen < Obstacle_Distance2)
  309   2          {
  310   3            Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  311   3            diff_pwm = Angle_Ring(0, gyro_z3) * 0.6;
  312   3            pwm = Speed_pid_Out(60, Sum_Pulse);
  313   3            Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  314   3          }
  315   2          else
  316   2          {
  317   3            Distance_Jifen = 0;
  318   3            time = 0;
  319   3            Obstacle_State = LObstacle_Over;
  320   3          }
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 6   

  321   2          break;
  322   2        case LObstacle_Over:
  323   2          Obstacle_Flag = 0;
  324   2          Inductance_Error = 0;
  325   2          Obstacle_State = NO_LObstacle; // 防止误判       // 打开正常循迹
  326   2          Elements_Num++;          // 元素表++
  327   2          speed = 60;
  328   2          Buzzer_OFF;
  329   2          break;
  330   2        }
  331   1      }
  332          /**
  333           *  @brief      右边六边环岛
  334           *  @param      圆环程序是否执行 1：执行 0 不执行
  335           *  @return     3：执行成功
  336           **/
  337          void RRoundabout(void)
  338          {
  339   1        static int YuanH_Flag = 1;
  340   1        static int Yu_YuanHuan_Flag = 0; // 预进圆环
  341   1        static int PanDuan_Flag = 1;   // 判断圆环
  342   1        static int Distance_Flag = 0;
  343   1        static int Yu_Chu_YuanHuan_Flag = 0; // 预出圆环
  344   1        static int Chu_YuanHuan_Flag = 0;  // 出圆环
  345   1        static int16 time = 0;
  346   1        static char Yuhuan;
  347   1        static char NO_Ring_Flag = 0;
  348   1        int pwm = 0;
  349   1        switch (Ring_state)
  350   1        {
  351   2        case NO_Ring:
  352   2          if ((L3_NOR_ADC + R3_NOR_ADC) > 60 && M1_NOR_ADC > 85)
  353   2          {
  354   3            In_Huan_Flag = 1;
  355   3            Ring_state = Fing_Ring; // 发现圆环
  356   3          }
  357   2          break;
  358   2        case Fing_Ring:       // 发现环
  359   2          Inductance_Error = 0; // 误差清零
  360   2          if (Distance_Flag == 0)
  361   2          {
  362   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  363   3            speed = 50;
  364   3            // Tracking(40);
  365   3          }
  366   2          if (bmq_jifen >= Yu_Distance)
  367   2          {
  368   3            bmq_jifen = 0;
  369   3            Distance_Flag = 1;
  370   3            gyro_z3 = 0;
  371   3          }
  372   2          if (Distance_Flag == 1) // 到达指定距离 角度打死
  373   2          {
  374   3            Inductance_Error = -45;
  375   3            speed = 50; // 圆内速度
  376   3            // Tracking(40);
  377   3            time++;
  378   3            if (time > 100)
  379   3            {
  380   4              Buzzer_ON;
  381   4              gyro_z3 = 0;
  382   4              Ring_state = In_Ring;
  383   4              Distance_Flag = 0;
  384   4              time = 0;
  385   4            }
  386   3          }
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 7   

  387   2          break;
  388   2        case In_Ring:
  389   2          time++;
  390   2          if (time > 200)
  391   2          {
  392   3            if ((L3_NOR_ADC + R3_NOR_ADC) >= 140 || M1_NOR_ADC > 75||R1_NOR_ADC>90)
  393   3            {
  394   4      
  395   4              Ring_state = Ready_Out_Ring;
  396   4              speed = 50; // 准备出圆环速度
  397   4              Buzzer_OFF;
  398   4            }
  399   3            else
  400   3            {
  401   4              speed = 70;
  402   4            }
  403   3          }
  404   2          break;
  405   2        case Ready_Out_Ring:
  406   2          if (Distance_Flag == 0)
  407   2          {
  408   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  409   3            speed = 50;
  410   3            Inductance_Error = -30;
  411   3            // Tracking(40);
  412   3          }
  413   2          if (bmq_jifen >= Chu_Distance + 1400)
  414   2          {
  415   3            bmq_jifen = 0;
  416   3            Distance_Flag = 1;
  417   3            // Motor_PWM(0, 0); // 速度清零
  418   3            time = 0;
  419   3          }
  420   2          if (Distance_Flag == 1) // 到达指定距离 角度打死
  421   2          {
  422   3            gyro_z3 = 0;
  423   3            Ring_state = Out_Ring;
  424   3            Distance_Flag = 0;
  425   3            time = 0;
  426   3          }
  427   2          break;
  428   2        case Out_Ring:
  429   2          time++;
  430   2          if (Distance_Flag == 0 && time > 50)
  431   2          {
  432   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  433   3            speed = 50;
  434   3          }
  435   2          if (bmq_jifen > End_Chu_Distance)
  436   2          {
  437   3            Ring_state = Ready_No_Ring;
  438   3            time = 0;
  439   3            bmq_jifen = 0;
  440   3            Buzzer_OFF;
  441   3          }
  442   2          break;
  443   2        case Ready_No_Ring: // 出圆环结束清除标志位
  444   2          speed = 75;
  445   2          Ring_state = Already_Out_Ring;
  446   2          Buzzer_OFF;
  447   2          In_Huan_Flag = 0; // 正常速度循迹
  448   2          break;
  449   2        case Already_Out_Ring:
  450   2          Ring_state = NO_Ring;
  451   2          Elements_Num++; // 元素表++
  452   2          Buzzer_OFF;
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 8   

  453   2          break;
  454   2        }
  455   1      }
  456          /**
  457           *  @brief      左六边环岛
  458           *  @param      圆环程序是否执行 1：执行 0 不执行
  459           *  @return     3：执行成功
  460           **/
  461          void LRoundabout(void)
  462          {
  463   1      
  464   1        static int YuanH_Flag = 1;
  465   1        static int Yu_YuanHuan_Flag = 0; // 预进圆环
  466   1        static int PanDuan_Flag = 1;   // 判断圆环
  467   1        static int Distance_Flag = 0;
  468   1        static int Yu_Chu_YuanHuan_Flag = 0; // 预出圆环
  469   1        static int Chu_YuanHuan_Flag = 0;  // 出圆环
  470   1        static int16 time = 0;
  471   1        static char Yuhuan;
  472   1        static char NO_Ring_Flag = 0;
  473   1        int pwm = 0;
  474   1        switch (Ring_state)
  475   1        {
  476   2        case NO_Ring:
  477   2          if ((L3_NOR_ADC + R3_NOR_ADC) > 60 && M1_NOR_ADC > 85)
  478   2          {
  479   3            In_Huan_Flag = 1;
  480   3            Ring_state = Fing_Ring; // 发现圆环
  481   3          }
  482   2          break;
  483   2        case Fing_Ring:       // 发现环
  484   2          Inductance_Error = 0; // 误差清零
  485   2          if (Distance_Flag == 0)
  486   2          {
  487   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  488   3            speed = 50;
  489   3            // Tracking(40);
  490   3          }
  491   2          if (bmq_jifen >= Yu_Distance)
  492   2          {
  493   3            bmq_jifen = 0;
  494   3            Distance_Flag = 1;
  495   3            gyro_z3 = 0;
  496   3          }
  497   2          if (Distance_Flag == 1) // 到达指定距离 角度打死
  498   2          {
  499   3            Inductance_Error = 45;
  500   3            speed = 40; // 圆内速度
  501   3            // Tracking(40);
  502   3            time++;
  503   3            if (time > 100)
  504   3            {
  505   4              Buzzer_ON;
  506   4              gyro_z3 = 0;
  507   4              Ring_state = In_Ring;
  508   4              Distance_Flag = 0;
  509   4              time = 0;
  510   4            }
  511   3          }
  512   2          break;
  513   2        case In_Ring:
  514   2          time++;
  515   2          if (time > 200)
  516   2          {
  517   3            if ((L3_NOR_ADC + R3_NOR_ADC) >= 140 || M1_NOR_ADC > 75 || L1_NOR_ADC > 90)
  518   3            {
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 9   

  519   4      
  520   4              Ring_state = Ready_Out_Ring;
  521   4              speed = 40; // 准备出圆环速度
  522   4              Buzzer_OFF;
  523   4            }
  524   3            else
  525   3            {
  526   4              speed = 70;
  527   4            }
  528   3          }
  529   2          break;
  530   2        case Ready_Out_Ring:
  531   2          if (Distance_Flag == 0)
  532   2          {
  533   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  534   3            speed = 50;
  535   3            Inductance_Error = 30;
  536   3            // Tracking(40);
  537   3          }
  538   2          if (bmq_jifen >= Chu_Distance + 1400)
  539   2          {
  540   3            bmq_jifen = 0;
  541   3            Distance_Flag = 1;
  542   3            // Motor_PWM(0, 0); // 速度清零
  543   3            time = 0;
  544   3          }
  545   2          if (Distance_Flag == 1) // 到达指定距离 角度打死
  546   2          {
  547   3            gyro_z3 = 0;
  548   3            Ring_state = Out_Ring;
  549   3            Distance_Flag = 0;
  550   3            time = 0;
  551   3          }
  552   2          break;
  553   2        case Out_Ring:
  554   2          time++;
  555   2          if (Distance_Flag == 0 && time > 50)
  556   2          {
  557   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  558   3            speed = 50;
  559   3          }
  560   2          if (bmq_jifen > End_Chu_Distance)
  561   2          {
  562   3            Ring_state = Ready_No_Ring;
  563   3            time = 0;
  564   3            bmq_jifen = 0;
  565   3            Buzzer_OFF;
  566   3          }
  567   2          break;
  568   2        case Ready_No_Ring: // 出圆环结束清除标志位
  569   2          speed = 60;
  570   2          Ring_state = Already_Out_Ring;
  571   2          Buzzer_OFF;
  572   2          In_Huan_Flag = 0; // 正常速度循迹
  573   2          break;
  574   2        case Already_Out_Ring:
  575   2          Ring_state = NO_Ring;
  576   2          Elements_Num++; // 元素表++
  577   2          Buzzer_OFF;
  578   2          break;
  579   2        }
  580   1      }
  581          /**
  582           * @brief 坡道
  583           *
  584           */
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 10  

  585          void Ramp(void)
  586          {
  587   1        static int Ramp_Time = 0;
  588   1        static int Flag = 0;
  589   1        if ((dl1a_distance_mm < 300 &&M1_NOR_ADC > 75)||Flag == 1)
  590   1        {
  591   2          Flag = 1;
  592   2          Ramp_Time++;
  593   2          Buzzer_ON;
  594   2          if (Ramp_Time > 50&&Ramp_Time<250)
  595   2          {
  596   3            speed = 25;//下坡减速
  597   3          }
  598   2          else if(Ramp_Time>=500)
  599   2          {
  600   3            speed = 70;
  601   3            Elements_Num++;
  602   3            Flag = 0;
  603   3            Buzzer_OFF;
  604   3          }
  605   2        }
  606   1      }
  607          /**
  608           *  @brief      基础循迹
  609           *  @param      void
  610           *  @return     void
  611           **/
  612          void Tracking(int Set_speed)
  613          {
  614   1        static int count = 0, pwm = 0;
  615   1        int LALL_PWM = 0, RALL_PWM = 0;
  616   1        float diff_Kp = 0;
  617   1        Sum_Pulse = (L_Pulse + R_Pulse) / 2;
  618   1        if (Obstacle_Flag == 0) // 避障时，关闭正常循迹
  619   1        {
  620   2          count++;
  621   2          dir_out = DirControl(-Inductance_Error*0.80);
  622   2          if (count >= 10)
  623   2          {
  624   3            pwm = Speed_pid_Out(Set_speed, Sum_Pulse); // 减或加一个方向环的输出
  625   3            count = 0;
  626   3          }
  627   2      
  628   2          LALL_PWM = pwm + dir_out;
  629   2          RALL_PWM = pwm - dir_out;
  630   2          LMotor_PWM = LALL_PWM;
  631   2          RMotor_PWM = RALL_PWM;
  632   2          // LALL_PWM = limit(LALL_PWM, 9500);
  633   2          // RALL_PWM = limit(RALL_PWM, 9500);
  634   2          Motor_PWM(LALL_PWM, RALL_PWM);
  635   2        }
  636   1      }
  637          
  638          /**
  639           * @brief 根据不同速度给标志位
  640           *
  641           */
  642          void Error_Speed(void)
  643          {
  644   1        if (abs(Inductance_Error) < 30)
  645   1          Err_speed = speed * 0.3;
  646   1        else if (abs(Inductance_Error) > 45 && abs(Inductance_Error) <= 30)
  647   1          Err_speed = speed * 0.1;
  648   1        else if (L2_NOR_ADC > 10 || R1_NOR_ADC > 10)
  649   1          Err_speed = speed * -0.2;
  650   1        else
C251 COMPILER V5.60.0,  TrackElement                                                       22/07/24  21:12:53  PAGE 11  

  651   1          Err_speed = 0;
  652   1      }
  653          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3105     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       190     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       390     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
