C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE TrackElement
OBJECT MODULE PLACED IN .\Out_File\TrackElement.obj
COMPILER INVOKED BY: F:\Keil_c251\C251\BIN\C251.EXE ..\USER\Hardware\TrackElement.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SP
                    -EED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\C
                    -ODE;..\USER\inc;..\USER\src;..\USER\Hardware;..\USER\Hardware) DEBUG PRINT(.\Out_File\TrackElement.lst) TABS(2) OBJECT(.
                    -\Out_File\TrackElement.obj) 

stmt  level    source

    1          /*
    2           * @Description:
    3           * @Author: Yzhi
    4           * @Date: 2024-01-10 09:24:18
    5           * @LastEditTime: 2024-01-10 09:32:32
    6           * @LastEditors: Yzhi
    7           */
    8          #include "myconfig.h"
    9          
   10          int Element_Order[4] = {0};
   11          
   12          int shizi_flag = 0;
   13          int ring_flag = -1;
   14          long bmq_jifen = 0;
   15          double angle_jifen = 0;
   16          int Track_flag = 0; // 正常循迹
   17          int set_speed = 0;  // 在赛道上不断更改速度
   18          
   19          int Elements_List[4];
   20          int Elements_Num = 0;
   21          
   22          //*******************避障*****************//
   23          uint8 Obstacle_State = 0; // 避障状态
   24          int Distance_Jifen = 0;
   25          int Obstacle_Distance1 = 2248; // 第一次直行的距离
   26          int Obstacle_Distance2 = 3548; // 第二次直行的距离
   27          
   28          int Obstacle_Flag = 0;
   29          
   30          //*******************环岛*****************//
   31          uint8 Ring_state = 0;
   32          
   33          int Yuan_TrackSpeed = 0; // 环内循迹速度
   34          
   35          int Yu_Speed = 1200;   // 预进环岛速度
   36          int Yu_Distance = 3000;  // 预进环岛距离
   37          int Yu_Speed_Diff = 800; // 打角的速度差异
   38          
   39          int Chu_Speed = 1000;   // 预出环岛速度
   40          int Chu_Distance = 4000;  // 预出环岛距离
   41          int Chu_Speed_Diff = 800; // 打角的速度差异
   42          
   43          int In_Huan_Flag = 0;
   44          
   45          #define Judgment_loop 1;
   46          
   47          int End_Chu_Distance = 4000; // 出环岛距离
   48          
   49          int Huan_Dao_Flag = 0;
   50          
   51          int ANGLE_FLAG = 0;    // 角度积分标志
   52          double Angle4 = 0;     // 角度积分
   53          int DISTANCE_FLAG = 0; // 距离积分标志
   54          long Distance = 0;     // 距离积分
   55          
   56          int RAngle_Flag = 0; // 90度标志位
C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 2   

   57          
   58          /*外环与电机pid与速度改变的参数*/
   59          
   60          double Sub_wh_p = 20;
   61          double Sub_wh_d = 10;
   62          double Sub_motor_p = 0;
   63          double Sub_motor_i = 0;
   64          int Sub_speed = -10;
   65          
   66          
   67          /*不同元素速度控制*/
   68          int Speed_Plan1 = 0;
   69          
   70          int Err_speed = 0;
   71          
   72          
   73          
   74          /**
   75           * @brief 向右避障
   76           *
   77           */
   78          void RObstacle(void)
   79          {
   80   1        int dir_out = 0, pwm = 0, diff_pwm, dir = 0;
   81   1        static int groy = 0, time = 0;
   82   1        switch (Obstacle_State)
   83   1        {
   84   2        case NO_LObstacle:
   85   2          if (dl1a_distance_mm < 1200)
   86   2          {
   87   3            // speed = 60;//降速
   88   3            Obstacle_State = Find_LObstacle;
   89   3            time = 0;
   90   3            gyro_z3 = 0;
   91   3            Buzzer_ON;
   92   3            Obstacle_Flag = 1; // 关闭正常循迹
   93   3          }
   94   2          break;
   95   2        case Find_LObstacle: // 拐角
   96   2          time++;
   97   2          pwm = Angle_Ring(52, gyro_z3);
   98   2          Motor_PWM(pwm, -pwm);
   99   2          if (time > 300)
  100   2          {
  101   3            time = 0;
  102   3            gyro_z3 = 0;
  103   3            Obstacle_State = LObstacle_straight;
  104   3          }
  105   2          break;
  106   2        case LObstacle_straight: // 直行
  107   2          if (Distance_Jifen < Obstacle_Distance1)
  108   2          {
  109   3            Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  110   3            diff_pwm = Angle_Ring(0, gyro_z3) * 0.6;
  111   3            pwm = Speed_pid_Out(55, Sum_Pulse);
  112   3            Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  113   3          }
  114   2          else
  115   2          {
  116   3            Distance_Jifen = 0;
  117   3            time = 0;
  118   3            gyro_z3 = 0;
  119   3            speed = 0;
  120   3            Obstacle_State = LObstacle_Angle1;
  121   3          }
  122   2          break;
C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 3   

  123   2        case LObstacle_Angle1: // 拐角
  124   2          time++;
  125   2          pwm = Angle_Ring(-120, gyro_z3);
  126   2          Motor_PWM(pwm, -pwm);
  127   2          if (time > 250)
  128   2          {
  129   3            time = 0;
  130   3            gyro_z3 = 0;
  131   3            Distance_Jifen = 0;
  132   3            Obstacle_State = LObstacle_straight1;
  133   3          }
  134   2          break;
  135   2        case LObstacle_straight1: // 直行
  136   2          if (Distance_Jifen < Obstacle_Distance2)
  137   2          {
  138   3            Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  139   3            diff_pwm = Angle_Ring(0, gyro_z3) * 0.6;
  140   3            pwm = Speed_pid_Out(55, Sum_Pulse);
  141   3            Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  142   3          }
  143   2          else
  144   2          {
  145   3            Distance_Jifen = 0;
  146   3            time = 0;
  147   3            Obstacle_State = LObstacle_Over;
  148   3          }
  149   2          break;
  150   2        case LObstacle_Angle12:
  151   2          time++;
  152   2          pwm = Angle_Ring(60, gyro_z3);
  153   2          Motor_PWM(pwm, -pwm);
  154   2          if (time > 200)
  155   2          {
  156   3            Obstacle_State = LObstacle_Over;
  157   3            time = 0;
  158   3            gyro_z3 = 0;
  159   3            Obstacle_Flag = 0;
  160   3          }
  161   2          break;
  162   2        case LObstacle_Over:
  163   2          Obstacle_Flag = 0;
  164   2          Inductance_Error = 0;
  165   2          Obstacle_State = 99; // 防止误判       // 打开正常循迹
  166   2          Elements_Num++;//元素表++
  167   2          Buzzer_OFF;
  168   2          break;
  169   2        }
  170   1      }
  171          
  172          /**
  173           * @brief 向左避障
  174           *
  175           */
  176          void LObstacle(void)
  177          {
  178   1        int dir_out = 0,pwm=0,diff_pwm,dir=0;
  179   1        static int groy = 0,time=0;
  180   1        switch (Obstacle_State)
  181   1        {
  182   2        case NO_LObstacle:
  183   2          if (dl1a_distance_mm < 1200)
  184   2          {
  185   3            //speed = 60;//降速
  186   3            Obstacle_State = Find_LObstacle;
  187   3            time = 0;
  188   3            gyro_z3 = 0;
C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 4   

  189   3            Buzzer_ON;
  190   3            Obstacle_Flag = 1; // 关闭正常循迹
  191   3          }
  192   2          break;
  193   2        case Find_LObstacle: //拐角
  194   2          time++;
  195   2          pwm=Angle_Ring(-50,gyro_z3);
  196   2          Motor_PWM(pwm, -pwm);
  197   2          if(time>250)
  198   2          {
  199   3            time = 0;
  200   3            gyro_z3 = 0;
  201   3            Obstacle_State = LObstacle_straight;
  202   3          }
  203   2          break;
  204   2        case LObstacle_straight: //直行
  205   2          if (Distance_Jifen < Obstacle_Distance1)
  206   2          {
  207   3            Distance_Jifen +=(R_Pulse + L_Pulse)/2;
  208   3            diff_pwm = Angle_Ring(0, gyro_z3)*0.6;
  209   3            pwm=Speed_pid_Out(40, Sum_Pulse);
  210   3            Motor_PWM(pwm+diff_pwm, pwm-diff_pwm);
  211   3          }
  212   2          else
  213   2          {
  214   3            Distance_Jifen = 0;
  215   3            time = 0;
  216   3            gyro_z3 = 0;
  217   3            speed = 0;
  218   3            Obstacle_State = LObstacle_Angle1;
  219   3          }
  220   2          break;
  221   2        case LObstacle_Angle1://拐角
  222   2          time++;
  223   2          pwm = Angle_Ring(120, gyro_z3);
  224   2          Motor_PWM(pwm, -pwm);
  225   2          if (time > 250)
  226   2          {
  227   3            time = 0;
  228   3            gyro_z3 = 0;
  229   3            Distance_Jifen = 0;
  230   3            Obstacle_State = LObstacle_straight1;
  231   3          }
  232   2          break;
  233   2        case LObstacle_straight1: //直行
  234   2          if (Distance_Jifen < Obstacle_Distance2)
  235   2          {
  236   3            Distance_Jifen += (R_Pulse + L_Pulse) / 2;
  237   3            diff_pwm = Angle_Ring(0, gyro_z3)*0.6;
  238   3            pwm = Speed_pid_Out(50, Sum_Pulse);
  239   3            Motor_PWM(pwm + diff_pwm, pwm - diff_pwm);
  240   3          }
  241   2          else
  242   2          {
  243   3            Distance_Jifen = 0;
  244   3            time = 0;
  245   3            Obstacle_State = LObstacle_Angle12;
  246   3          }
  247   2          break;
  248   2        case LObstacle_Angle12:
  249   2          time++;
  250   2          pwm = Angle_Ring(-60, gyro_z3);
  251   2          Motor_PWM(pwm, -pwm);
  252   2          if(time>200)
  253   2          {
  254   3            Obstacle_State = LObstacle_Over;
C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 5   

  255   3            time = 0;
  256   3            gyro_z3 = 0;
  257   3            Obstacle_Flag = 0; // 打开正常循迹
  258   3          }
  259   2          break;
  260   2        case LObstacle_Over:
  261   2          speed = 0;
  262   2          Inductance_Error = 0;
  263   2          Obstacle_State = 99; // 防止误判
  264   2          Obstacle_Flag = 0;//打开正常循迹
  265   2          Buzzer_OFF;
  266   2          break;
  267   2        }
  268   1      }
  269          /**
  270           *  @brief      右边六边环岛
  271           *  @param      圆环程序是否执行 1：执行 0 不执行
  272           *  @return     3：执行成功
  273           **/
  274          void RRoundabout(void)
  275          {
  276   1        static int YuanH_Flag = 1;
  277   1        static int Yu_YuanHuan_Flag = 0; // 预进圆环
  278   1        static int PanDuan_Flag = 1;   // 判断圆环
  279   1        static int Distance_Flag = 0;
  280   1        static int Yu_Chu_YuanHuan_Flag = 0; // 预出圆环
  281   1        static int Chu_YuanHuan_Flag = 0;  // 出圆环
  282   1        static int16 time = 0;
  283   1        static char Yuhuan;
  284   1        static char NO_Ring_Flag = 0;
  285   1        int pwm = 0;
  286   1        switch (Ring_state)
  287   1        {
  288   2        case NO_Ring:
  289   2          if ((L3_NOR_ADC + R3_NOR_ADC) > 60 && M1_NOR_ADC > 85)
  290   2          {
  291   3            In_Huan_Flag = 1;
  292   3            Ring_state = Fing_Ring; // 发现圆环
  293   3          }
  294   2          break;
  295   2        case Fing_Ring:       // 发现环
  296   2          Inductance_Error = 0; // 误差清零
  297   2          if (Distance_Flag == 0)
  298   2          {
  299   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  300   3            speed = -80;
  301   3            // Tracking(40);
  302   3          }
  303   2          if (bmq_jifen >= Yu_Distance)
  304   2          {
  305   3            bmq_jifen = 0;
  306   3            Distance_Flag = 1;
  307   3            gyro_z3 = 0;
  308   3          }
  309   2          if (Distance_Flag == 1) // 到达指定距离 角度打死
  310   2          {
  311   3            Inductance_Error = -45;
  312   3            speed = 80;
  313   3            // Tracking(40);
  314   3            time++;
  315   3            if (time > 150)
  316   3            {
  317   4              Buzzer_ON;
  318   4              gyro_z3 = 0;
  319   4              Ring_state = In_Ring;
  320   4              Distance_Flag = 0;
C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 6   

  321   4              time = 0;
  322   4            }
  323   3          }
  324   2          break;
  325   2        case In_Ring:
  326   2          if ((L3_NOR_ADC + R3_NOR_ADC) >= 100 || M1_NOR_ADC > 85)
  327   2          {
  328   3      
  329   3            Ring_state = Ready_Out_Ring;
  330   3            Buzzer_OFF;
  331   3          }
  332   2          else
  333   2          {
  334   3            Wh_P = 80;
  335   3            Wh_D = 160; // 圆环内PID
  336   3            speed = 85;
  337   3          }
  338   2          break;
  339   2        case Ready_Out_Ring:
  340   2          if (Distance_Flag == 0)
  341   2          {
  342   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  343   3            speed = 85;
  344   3            Inductance_Error = 0;
  345   3            // Tracking(40);
  346   3          }
  347   2          if (bmq_jifen >= Chu_Distance)
  348   2          {
  349   3            bmq_jifen = 0;
  350   3            Distance_Flag = 1;
  351   3            // Motor_PWM(0, 0); // 速度清零
  352   3            time = 0;
  353   3          }
  354   2          if (Distance_Flag == 1) // 到达指定距离 角度打死
  355   2          {
  356   3            gyro_z3 = 0;
  357   3            Ring_state = Out_Ring;
  358   3            Distance_Flag = 0;
  359   3            time = 0;
  360   3          }
  361   2          break;
  362   2        case Out_Ring:
  363   2          time++;
  364   2          if (time > 100)
  365   2          {
  366   3            if (Distance_Flag == 0)
  367   3            {
  368   4              bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  369   4              // Inductance_Error = 0;
  370   4              speed = 85;
  371   4              // Tracking(45);
  372   4            }
  373   3            if (bmq_jifen > End_Chu_Distance)
  374   3            {
  375   4              Ring_state = Ready_No_Ring;
  376   4              // Buzzer_OFF;
  377   4            }
  378   3          }
  379   2          else
  380   2          {
  381   3            Inductance_Error = 30; // 小打角
  382   3          }
  383   2          break;
  384   2        case Ready_No_Ring: // 出圆环结束清除标志位
  385   2          Wh_P = 160;   // 回到正常PID
  386   2          Wh_D = 240;
C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 7   

  387   2          Ring_state = Already_Out_Ring;
  388   2          Buzzer_OFF;
  389   2          In_Huan_Flag = 0; // 正常速度循迹
  390   2          break;
  391   2        case Already_Out_Ring:
  392   2          Ring_state = 99;
  393   2          Elements_Num++; // 元素表++
  394   2          Buzzer_OFF;
  395   2          break;
  396   2        }
  397   1      }
  398          /**
  399           *  @brief      左六边环岛
  400           *  @param      圆环程序是否执行 1：执行 0 不执行
  401           *  @return     3：执行成功
  402           **/
  403          void LRoundabout(void)
  404          {
  405   1        static int YuanH_Flag = 1;
  406   1        static int Yu_YuanHuan_Flag = 0; // 预进圆环
  407   1        static int PanDuan_Flag = 1;   // 判断圆环
  408   1        static int Distance_Flag = 0;
  409   1        static int Yu_Chu_YuanHuan_Flag = 0; // 预出圆环
  410   1        static int Chu_YuanHuan_Flag = 0;  // 出圆环
  411   1        static int16 time = 0;
  412   1        static char Yuhuan;
  413   1        static char NO_Ring_Flag = 0;
  414   1        int pwm = 0;
  415   1        switch (Ring_state)
  416   1        {
  417   2        case NO_Ring:
  418   2          if ((L3_NOR_ADC+R3_NOR_ADC)>60&&M1_NOR_ADC>85)
  419   2          {
  420   3            In_Huan_Flag = 1;
  421   3            Ring_state = Fing_Ring; // 发现圆环
  422   3          }
  423   2          break;
  424   2        case Fing_Ring:       // 发现环
  425   2          Inductance_Error = 0; // 误差清零
  426   2          if (Distance_Flag == 0)
  427   2          {
  428   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  429   3            speed = 80;
  430   3            //Tracking(40);
  431   3          }
  432   2          if (bmq_jifen >= Yu_Distance)
  433   2          {
  434   3            bmq_jifen = 0;
  435   3            Distance_Flag = 1;
  436   3            gyro_z3 = 0;
  437   3          }
  438   2          if (Distance_Flag == 1) // 到达指定距离 角度打死
  439   2          {
  440   3            Inductance_Error = 45;
  441   3            speed = 80;
  442   3            //Tracking(40);
  443   3            time++;
  444   3            if (time>150)
  445   3            {
  446   4              Buzzer_ON;
  447   4              gyro_z3 = 0;
  448   4              Ring_state = In_Ring;
  449   4              Distance_Flag = 0;
  450   4              time = 0;
  451   4            }
  452   3          }
C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 8   

  453   2          break;
  454   2        case In_Ring:
  455   2          if ((L3_NOR_ADC+R3_NOR_ADC)>=100||M1_NOR_ADC>85)
  456   2          {
  457   3      
  458   3            Ring_state = Ready_Out_Ring;
  459   3            Buzzer_OFF;
  460   3          }
  461   2          else
  462   2          {
  463   3            Wh_P = 80;
  464   3            Wh_D = 160; //圆环内PID
  465   3            speed = 85;
  466   3          }
  467   2          break;
  468   2        case Ready_Out_Ring:
  469   2          if (Distance_Flag == 0)
  470   2          {
  471   3            bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  472   3            speed = 85;
  473   3            Inductance_Error = 0;
  474   3            //Tracking(40);
  475   3          }
  476   2          if (bmq_jifen >= Chu_Distance)
  477   2          {
  478   3            bmq_jifen = 0;
  479   3            Distance_Flag = 1;
  480   3            // Motor_PWM(0, 0); // 速度清零
  481   3            time = 0;
  482   3          }
  483   2          if (Distance_Flag == 1) // 到达指定距离 角度打死
  484   2          {
  485   3              gyro_z3 = 0;
  486   3              Ring_state = Out_Ring;
  487   3              Distance_Flag = 0;
  488   3              time = 0;
  489   3          }
  490   2          break;
  491   2        case Out_Ring:
  492   2          time++;
  493   2          if(time>100)
  494   2          {
  495   3            if (Distance_Flag == 0)
  496   3            {
  497   4              bmq_jifen += (R_Pulse + L_Pulse) / 2; // 编码器积分距离
  498   4              //Inductance_Error = 0;
  499   4              speed = 85;
  500   4              //Tracking(45);
  501   4            }
  502   3            if (bmq_jifen > End_Chu_Distance)
  503   3            {
  504   4              Ring_state = Ready_No_Ring;
  505   4              //Buzzer_OFF;
  506   4            }
  507   3          }
  508   2          else
  509   2            {
  510   3              Inductance_Error = 30;//小打角
  511   3            }
  512   2          break;
  513   2        case Ready_No_Ring: // 出圆环结束清除标志位
  514   2          Wh_P = 160;  //回到正常PID
  515   2          Wh_D = 240;
  516   2          Ring_state = Already_Out_Ring;
  517   2          Buzzer_OFF;
  518   2          In_Huan_Flag = 0; // 正常速度循迹
C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 9   

  519   2          break;
  520   2        case Already_Out_Ring:
  521   2          Ring_state = 99;
  522   2          Buzzer_OFF;
  523   2          break;
  524   2        }
  525   1      }
  526          /**
  527           * @brief 坡道
  528           * 
  529           */
  530          void Ramp(void)
  531          {
  532   1        static int Ramp_Time = 0;
  533   1        static int Flag = 0;
  534   1        if (dl1a_distance_mm < 500 || Flag==1)
  535   1        {
  536   2          Flag = 1;
  537   2          Ramp_Time++;
  538   2          if(Ramp_Time>1000)
  539   2          {
  540   3            Elements_Num++;
  541   3          }
  542   2        }
  543   1      }
  544          /**
  545           *  @brief      基础循迹
  546           *  @param      void
  547           *  @return     void
  548           **/
  549          void Tracking(int Set_speed)
  550          {
  551   1        static int count = 0, pwm = 0, LALL_PWM = 0, RALL_PWM = 0;
  552   1        Sum_Pulse = (L_Pulse + R_Pulse) / 2;
  553   1        count++;
  554   1        if(Obstacle_Flag==0) //避障时，关闭正常循迹
  555   1          {
  556   2          dir_out = DirControl(-Inductance_Error);
  557   2          if (count == 10)
  558   2          {
  559   3            pwm = Speed_pid_Out(Set_speed, Sum_Pulse); // 减或加一个方向环的输出
  560   3            count = 0;
  561   3          }
  562   2          LALL_PWM = pwm + dir_out;
  563   2          RALL_PWM = pwm - dir_out;
  564   2          Motor_PWM(LALL_PWM, RALL_PWM);
  565   2        }
  566   1      }
  567          
  568          /**
  569           * @brief 根据不同速度给标志位
  570           *
  571           */
  572          void Error_Speed(void)
  573          {
  574   1        if(abs(Inductance_Error)<30)
  575   1          Err_speed = speed*0.2;
  576   1        else if (abs(Inductance_Error) >45&&abs(Inductance_Error)<=30)
  577   1          Err_speed = speed * 0.1;
  578   1        else if (L2_NOR_ADC > 10 || R1_NOR_ADC > 10)
  579   1            Err_speed = speed * -0.2;
  580   1        else 
  581   1          Err_speed = 0;
  582   1      }


C251 COMPILER V5.60.0,  TrackElement                                                       17/07/24  21:01:24  PAGE 10  

Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3069     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       174     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       390     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
